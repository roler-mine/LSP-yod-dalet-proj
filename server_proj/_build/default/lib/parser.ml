
(* This generated code requires the following version of MenhirLib: *)

let () =
  MenhirLib.StaticVersion.require_20250912

module MenhirBasics = struct
  
  exception Error
  
  let _eRR =
    fun _s ->
      raise Error
  
  type token = 
    | XOR
    | WHILE
    | TRUE
    | TERM
    | TABLE
    | STRINGLIT of (
# 28 "lib/parser.mly"
       (string)
# 25 "lib/parser.ml"
  )
    | STOP
    | START
    | STAR
    | SLASH
    | SEMI
    | RPAREN
    | RETURN
    | REF
    | PROC
    | POW
    | PLUS
    | OR
    | NOT
    | NE
    | MOD
    | MINUS
    | LT
    | LPAREN
    | LE
    | ITEM
    | INTLIT of (
# 26 "lib/parser.mly"
       (string)
# 50 "lib/parser.ml"
  )
    | IF
    | ID of (
# 25 "lib/parser.mly"
       (string)
# 56 "lib/parser.ml"
  )
    | GT
    | GOTO
    | GE
    | FOR
    | FLOATLIT of (
# 27 "lib/parser.mly"
       (string)
# 65 "lib/parser.ml"
  )
    | FALSE
    | EXIT
    | EQV
    | EQ
    | EOF
    | END
    | ELSE
    | DOT
    | DEFAULT
    | DEF
    | COMMA
    | COLON
    | CHARLIT of (
# 29 "lib/parser.mly"
       (char)
# 82 "lib/parser.ml"
  )
    | CASE
    | BY
    | BEGIN
    | BANG
    | AT
    | AND
    | ABORT
  
end

include MenhirBasics

# 3 "lib/parser.mly"
  
  open Ast

  let loc sp ep = Ast.Loc.of_lexing_positions_no_file sp ep
  let n sp ep v = Ast.node ~loc:(loc sp ep) v
  let nid sp ep s = Ast.node ~loc:(loc sp ep) s

  let mk_block sp ep (ss : Ast.stmt Ast.node list) : Ast.stmt Ast.node =
    n sp ep (Ast.SBlock ss)

  let wrap_labels (labels : Ast.ident list) (s : Ast.stmt Ast.node) : Ast.stmt Ast.node =
    List.fold_right
      (fun (lab : Ast.ident) acc ->
        Ast.node ~loc:acc.loc (Ast.SLabel { label = lab; body = acc }))
      labels
      s

# 114 "lib/parser.ml"

module Tables = struct
  
  include MenhirBasics
  
  let token2terminal : token -> int =
    fun _tok ->
      match _tok with
      | ABORT ->
          54
      | AND ->
          53
      | AT ->
          52
      | BANG ->
          51
      | BEGIN ->
          50
      | BY ->
          49
      | CASE ->
          48
      | CHARLIT _ ->
          47
      | COLON ->
          46
      | COMMA ->
          45
      | DEF ->
          44
      | DEFAULT ->
          43
      | DOT ->
          42
      | ELSE ->
          41
      | END ->
          40
      | EOF ->
          39
      | EQ ->
          38
      | EQV ->
          37
      | EXIT ->
          36
      | FALSE ->
          35
      | FLOATLIT _ ->
          34
      | FOR ->
          33
      | GE ->
          32
      | GOTO ->
          31
      | GT ->
          30
      | ID _ ->
          29
      | IF ->
          28
      | INTLIT _ ->
          27
      | ITEM ->
          26
      | LE ->
          25
      | LPAREN ->
          24
      | LT ->
          23
      | MINUS ->
          22
      | MOD ->
          21
      | NE ->
          20
      | NOT ->
          19
      | OR ->
          18
      | PLUS ->
          17
      | POW ->
          16
      | PROC ->
          15
      | REF ->
          14
      | RETURN ->
          13
      | RPAREN ->
          12
      | SEMI ->
          11
      | SLASH ->
          10
      | STAR ->
          9
      | START ->
          8
      | STOP ->
          7
      | STRINGLIT _ ->
          6
      | TABLE ->
          5
      | TERM ->
          4
      | TRUE ->
          3
      | WHILE ->
          2
      | XOR ->
          1
  
  and error_terminal =
    0
  
  and token2value : token -> Obj.t =
    fun _tok ->
      match _tok with
      | ABORT ->
          Obj.repr ()
      | AND ->
          Obj.repr ()
      | AT ->
          Obj.repr ()
      | BANG ->
          Obj.repr ()
      | BEGIN ->
          Obj.repr ()
      | BY ->
          Obj.repr ()
      | CASE ->
          Obj.repr ()
      | CHARLIT _v ->
          Obj.repr (_v : (
# 29 "lib/parser.mly"
       (char)
# 256 "lib/parser.ml"
          ))
      | COLON ->
          Obj.repr ()
      | COMMA ->
          Obj.repr ()
      | DEF ->
          Obj.repr ()
      | DEFAULT ->
          Obj.repr ()
      | DOT ->
          Obj.repr ()
      | ELSE ->
          Obj.repr ()
      | END ->
          Obj.repr ()
      | EOF ->
          Obj.repr ()
      | EQ ->
          Obj.repr ()
      | EQV ->
          Obj.repr ()
      | EXIT ->
          Obj.repr ()
      | FALSE ->
          Obj.repr ()
      | FLOATLIT _v ->
          Obj.repr (_v : (
# 27 "lib/parser.mly"
       (string)
# 286 "lib/parser.ml"
          ))
      | FOR ->
          Obj.repr ()
      | GE ->
          Obj.repr ()
      | GOTO ->
          Obj.repr ()
      | GT ->
          Obj.repr ()
      | ID _v ->
          Obj.repr (_v : (
# 25 "lib/parser.mly"
       (string)
# 300 "lib/parser.ml"
          ))
      | IF ->
          Obj.repr ()
      | INTLIT _v ->
          Obj.repr (_v : (
# 26 "lib/parser.mly"
       (string)
# 308 "lib/parser.ml"
          ))
      | ITEM ->
          Obj.repr ()
      | LE ->
          Obj.repr ()
      | LPAREN ->
          Obj.repr ()
      | LT ->
          Obj.repr ()
      | MINUS ->
          Obj.repr ()
      | MOD ->
          Obj.repr ()
      | NE ->
          Obj.repr ()
      | NOT ->
          Obj.repr ()
      | OR ->
          Obj.repr ()
      | PLUS ->
          Obj.repr ()
      | POW ->
          Obj.repr ()
      | PROC ->
          Obj.repr ()
      | REF ->
          Obj.repr ()
      | RETURN ->
          Obj.repr ()
      | RPAREN ->
          Obj.repr ()
      | SEMI ->
          Obj.repr ()
      | SLASH ->
          Obj.repr ()
      | STAR ->
          Obj.repr ()
      | START ->
          Obj.repr ()
      | STOP ->
          Obj.repr ()
      | STRINGLIT _v ->
          Obj.repr (_v : (
# 28 "lib/parser.mly"
       (string)
# 354 "lib/parser.ml"
          ))
      | TABLE ->
          Obj.repr ()
      | TERM ->
          Obj.repr ()
      | TRUE ->
          Obj.repr ()
      | WHILE ->
          Obj.repr ()
      | XOR ->
          Obj.repr ()
  
  and default_reduction =
    (8, "\000\138\000n[m\000\000\000\000ge\000\000\000\000cdhfv\000\000\000\000\000\000wzy\000xK\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000I\000{7\0006\000\000\163\152\154\000\132\000\000\000\000\000\0002\\\000]\000W\000\000\000\000\000\000\000\000\000\000\000Q3\000\000\000\000\000\r\000\000\000\000\000\000\000\022\023\000\002\141\151\000\156\157\144\019\147\000\000\000\000\000\000k\140\000\000\000\004\012\146\142\149\143\148\145\150\000\000\018\000\024\000\021\153b\000`\007\000\025\tp\030\139\000\000\000\000 \000\000\000\000\000\000\155'\000\000%\000\000\000\000\000\000\000N\000\000\160\000\000\000\000\000\159\000\137\000\131\136\000\027\000\000\000\000\000YZ\000\000sR\000VT\000\000\133\000\000\000\000\000\000\026\000()+*\0000/\000\000-\135\134\000\000}~\028o\029\000\000\127\129\001\000\128")
  
  and error =
    (55, "7\135\000\189y\t\162\000\000\000\000\000\000\000\252\028\002\245\228&\136\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\012\193\000'^ h\153\130\000N\188@\2093\004\000\157x\001\130$\000\165(`\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001 \005)C\000\016\002@\nR\134\000 \004\128\020\165\012\000@\t\000)J\024\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\014o\159\251\255\196\253\196\130\020\165\012\000@9\190\127\239\255\003\247\018\000\000\1480\001\000\230\249\255\191\252O\220\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\209\222\133\012\b\bH\001JP\192\004\003\155\231\254\255\240?1 \005)C\000\016\014o\159\251\255\192\252\196\128\020\165\012\000@9\190\127\239\255\003\243\018\000R\1480\001\000\230\249\255\191\252\015\204H\001JP\192\004\003\155\231\254\255\240?1 \005)C\000\016\014o\159\251\255\192\252\196\128\020\165\012\000@9\190{N\190\003\243\018\000R\1480\001\000\230\249\255\191\252\015\204H\001JP\192\004\003\155\231\180\235\224?1 \005)C\000\016\014o\158\211\175\128\252\196\128\020\165\012\000@9\190{N\190\003\243\018\000R\1480\001\000\230\249\237:\248\015\204H\001JP\192\004\003\155\231\180\235\224?1 \005)C\000\016\014o\159\251\255\192\252\196\128\020\165\012\000@9\190\127\239\255\003\243\018\000R\1480\001\000\230\249\255\191\252\015\204H\001JP\192\004\000\000\000\000\000\000\000\004\006\142\244(`\000@\000\000\000\000\000\000\000\000\000\000\000\000\0009\190\127\239\255\003\243\000\000\000\000\000\000\000\128\225\222\133\012\000\b\204\016\002u\224\006\136\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\132\020\165\012\001@\000\000\000\000\000\000\000@p\239B\134\004\004$\000\165(`\002\001\205\211\191\127\248\006\153\152 \004\235\192\r\019\240p\011\215\156\154&`\128\019\175\0004@\000\000\000\000\000\000\000\000\000\000\000\000\000?\007\000\189y\201\162\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000@\004\128\020\165\012\000@08w\161C\000\"\018\000R\1480\001\000\192\225\222\133\012\000\b\128@\000\000\000\000\000\144\002\148\161\128\b\004\007\014\244(`\000@\002\000\000\000\000\000\012\193\000'^\000h\128\000\000\000\000\000\000\000\000\000\000\000\000\000$\000\165(`\002\001\001\195\189\n\024\000\016\000\000\000\000\000\001\000\000\000\b\000\b\000\002@\nR\134\002 \000\000\000\000\000\000\000 4w\161C\003\002\018\000R\1480\001\000\128\209\222\133\012\012\bH\001JP\192\004\002\003Gz\0200  \000\128\000\000\000\000\000\000\000\000\000\000B\000\000\000\000\000\000\000\000\000\000\000\000\000\0003\004\000\157x\001\130\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\016 \000\000\000\000\016\000\001 \005)C\000\016\b\014\029\232P\192\128\128\000\000\000\000\129\000\t\000\000J\024\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\002\000\b\144 \144B\148\161\128\b\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\001\000\t\000)J\024\b\128\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\004\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\b\000@\001\019\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\001\000 \000\000\000\000\000\000\b\000\000\000\000\000\002\000\000\000\000\146B\148\161\128\b\000\000\000\000\000\000\000\b\r\029\232P\192\192\132\128\020\165\012\000@ 4w\161C\003\002\018\000R\1480\001\000\128\209\222\133\012\b\b\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\000\128\004\144\020\165\012\000@\000\000\000\000\000\000\000\000\016\000\000\000\004\000\000\000\000\000\000\000@\000\000\000\128\002\000\000\000\000\000 \000\000\000\000\000\000@\000\000\002B\nR\134\000\160\000\004\000\000\000\001\000\000\000\000\000\000\000\000@p\239B\134\004\004$ \165(`\n\000\000\000\000\000\000\000\002\147\135\254\181\176(! \005)C\000\016\nN\031\250\214\192\160\132\128\020\165\012\000@)8\127\235[\002\130\000\000\000\000\000\000\000\000\000\000@\001\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\000 \001\000\000\b\000\000 \000\016\000\000\000\000@\000 \0000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\001\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\001\000\031\131\128^\188\132\209\000\000\000\000\000\000\000n\012\001z\241\019D\016\000\000\128\000\000\000\000\000\000 \000\000\000\000\000\000@\000\000\002B\nR\134\000\160\000\004\000\000\000\001\000\000\000\000\000\000\000\000\002\016\000\020 \004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\004\000\004\000\000(@\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006`\128\019\175\0164@\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\016\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000")
  
  and start =
    1
  
  and action =
    ((16, "\011\006\000\000\t:\000\000\000\000\000\000\005\230\012j\006R\015(\000\000\000\000\015(\015(\015(\015(\000\000\000\000\000\000\000\000\000\000\000j\015^\000\214\006R\000\003\006R\000\000\000\000\000\000\001\022\000\000\000\000\012(\015(\001\174\015(\001B\015(\002\134\015(\004\162\015(\005\014\015(\0046\015(\007 \015(\003^\015(\006\180\015(\007\248\015(\007\140\015(\b\208\015(\bd\015(\002\026\015(\003\202\015(\005z\015(\000\000\t\158\000\000\000\000\002\242\000\000\014\136\005\230\000\000\000\000\000\000\015\138\000\000\r\164\015(\005\230\005\230\n8\005\230\000\000\000\000\n8\000\000\006R\000\000\006R\000\238\015(\011\206\015(\012(\001&\015(\014\186\001H\005\230\000\000\000\000\015(\014\236\000\252\001h\015(\000\000\rX\015(\012\192\015(\011\206\001^\001\160\000\000\000\000\006R\000\000\000\000\000\000\001<\000\000\000\000\000\000\000\000\000\000\000\n\000\b\015(\r\240\000.\006R\000\000\000\000\012\170\015^\000\164\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\015(\000\000\000p\000\000\001h\000\000\000\000\000\000\012\170\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000\000\000\003\006R\000\252\015(\000\000\r\012\015(\011j\015(\005\230\000\220\000\000\000\000\000\206\015(\000\000\0016\000\166\000\142\006R\006R\015(\001<\000\000\014<\015^\000\000\006R\015(\t\238\015(\t\158\000\000\000j\000\000\000\214\000\000\000\000\001<\000\000\006R\005\178\006R\t:\006R\000\000\000\000\000\200\006R\000\000\000\000\000\218\000\000\000\000\001<\n\162\000\000\011j\000\003\006R\006R\015(\001<\000\000\012P\000\000\000\000\000\000\000\000\001<\000\000\000\000\000^\012P\000\000\000\000\000\000\005\230\0006\000\000\000\000\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\0005\000\000"), (16, "\001\209\001\209\001\209\003\246\002\166\001\209\001\209\000A\001\209\001\209\001\209\001\209\001\209\004\011\003B\001\209\001\209\001\209\001\209\001\209\001\209\001\209\001\209\000Z\001\209\003\142\001\209\001\209\001\209\001\209\001\209\001\209\001\209\001\209\001\209\001\209\001\209\001\209\003\255\003\251\002^\000j\002\018\001\161\001\209\001\209\001\209\001\209\001\209\001\209\001\161\001\209\001\209\001\209\001\205\001\205\001\205\000b\000\173\001\205\001\205\001\165\001\205\001\205\001\205\001\205\001\205\003\222\002\030\001\205\001\205\001\205\001\205\001\205\001\205\001\205\001\205\000Z\001\205\002\238\001\205\001\205\001\205\001\205\001\205\001\205\001\205\001\205\001\205\001\205\001\205\001\205\003\198\001=\0026\000j\002j\002\238\001\205\001\205\001\205\001\205\001\205\001\205\002\142\001\205\001\205\001\205\000\205\000\205\000\205\0019\001\197\000\205\000\205\000\141\000\205\000\205\000\205\000\205\000\205\003r\002\206\000\205\000\205\000\205\000\205\000\205\000\205\000\205\000\205\000\205\000\205\002\234\000\205\000\205\000\205\000\205\000\205\000\205\000\205\000\205\000\205\000\205\000\205\000\205\003b\0032\002\218\001\142\002\174\000~\000\205\000\205\000\205\000\205\000\205\000\205\002\129\000b\000\205\000\205\000\225\000\225\000\225\001z\002\005\000\225\000\225\001\246\000\225\000\225\000\225\000\225\000\225\001\154\001\178\000\154\000\225\000\225\000\225\000\225\000\225\000\225\000\225\000\225\000\225\001\214\000\225\000\225\000\225\000\225\000\225\000\225\000\225\000\225\000\225\000\225\000\225\000\225\002\230\000\000\000\000\001\250\001\182\000\000\000\225\000\225\000\225\000\225\000\225\000\225\000\000\000\000\000\225\000\225\001\021\001\021\001\021\000\000\000M\001\021\001\021\000\000\000\146\000\162\001\021\001\021\001\021\000\000\000\000\000\154\000\170\001\021\001\021\000\186\000\178\000\194\000\202\001\021\000\210\000\000\001\021\001\021\001\021\000\218\001\021\000\226\001\021\001\021\001\021\001\021\001\021\000\234\001\218\000\000\000\000\000\000\000\000\001\222\001\021\001\021\001\021\001\021\001\021\001\021\000\000\000\000\000\242\001\021\001\r\001\r\001\r\000\000\000\000\001\r\001\r\000\000\000\146\000\162\001\r\001\r\001\r\000\000\000\000\000\154\000\170\001\r\001\r\000\186\000\178\000\194\000\202\001\r\000\210\000\000\001\r\001\r\001\r\000\218\001\r\000\226\001\r\001\r\001\r\001\r\001\r\000\234\000\000\000\000\000\000\000\000\000\000\000\000\001\r\001\r\001\r\001\r\001\r\001\r\000\000\000\000\001\r\001\r\000\221\000\221\000\221\000\000\000\000\000\221\000\221\000\000\000\221\000\221\000\221\000\221\000\221\000\000\000\000\000\154\000\221\000\221\000\221\000\221\000\221\000\221\000\221\000\221\000\221\000\000\000\221\000\221\000\221\000\221\000\221\000\221\000\221\000\221\000\221\000\221\000\221\000\221\000\000\000\000\000\000\000\000\000\000\000\000\000\221\000\221\000\221\000\221\000\221\000\221\000\000\000\000\000\221\000\221\000\209\000\209\000\209\000\000\000\000\000\209\000\209\000\000\000\146\000\162\000\209\000\209\000\209\000\000\000\000\000\154\000\170\000\209\000\209\000\186\000\178\000\194\000\202\000\209\000\210\000\000\000\209\000\209\000\209\000\218\000\209\000\226\000\209\000\209\000\209\000\209\000\209\000\234\000\000\000\000\000\000\000\000\000\000\000\000\000\209\000\209\000\209\000\209\000\209\000\209\000\000\000\000\000\209\000\209\000\241\000\241\000\241\000\000\000\000\000\241\000\241\000\000\000\146\000\162\000\241\000\241\000\241\000\000\000\000\000\154\000\241\000\241\000\241\000\241\000\178\000\241\000\241\000\241\000\241\000\000\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\000\000\000\000\000\000\000\000\000\000\000\000\241\000\241\000\241\000\241\000\241\000\241\000\000\000\000\000\241\000\241\000\138\001\017\001\017\000\000\000\000\001\017\001\017\000\000\000\146\000\162\001\017\001\017\001\017\000\000\000\000\000\154\000\170\001\017\001\017\000\186\000\178\000\194\000\202\001\017\000\210\000\000\001\017\001\017\001\017\000\218\001\017\000\226\001\017\001\017\001\017\001\017\001\002\000\234\000\000\000\000\000\000\000\000\000\000\000\000\001\017\001\017\001\017\001\017\001\017\001\017\000\000\000\000\000\242\001\017\000\233\000\233\000\233\000\000\000\000\000\233\000\233\000\000\000\233\000\233\000\233\000\233\000\233\000\000\000\000\000\154\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\000\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\000\000\000\000\000\000\000\000\000\000\000\000\233\000\233\000\233\000\233\000\233\000\233\000\000\000\000\000\233\000\233\000\229\000\229\000\229\000\000\000\000\000\229\000\229\000\000\000\229\000\229\000\229\000\229\000\229\000\000\000\000\000\154\000\229\000\229\000\229\000\229\000\229\000\229\000\229\000\229\000\229\000\000\000\229\000\229\000\229\000\229\000\229\000\229\000\229\000\229\000\229\000\229\000\229\000\229\000\000\000\000\000\000\000\000\000\000\000\000\000\229\000\229\000\229\000\229\000\229\000\229\000\000\000\000\000\229\000\229\000\237\000\237\000\237\000\000\000\000\000\237\000\237\000\000\000\146\000\162\000\237\000\237\000\237\000\000\000\000\000\154\000\237\000\237\000\237\000\237\000\178\000\237\000\237\000\237\000\237\000\000\000\237\000\237\000\237\000\237\000\237\000\237\000\237\000\237\000\237\000\237\000\237\000\237\000\000\000\000\000\000\000\000\000\000\000\000\000\237\000\237\000\237\000\237\000\237\000\237\000\000\000\000\000\237\000\237\001\025\001\025\001\025\000\000\000\000\001\025\001\025\000\000\000\146\000\162\001\025\001\025\001\025\000\000\000\000\000\154\000\170\001\025\001\025\000\186\000\178\000\194\000\202\001\025\000\210\000\000\001\025\001\025\001\025\000\218\001\025\000\226\001\025\001\025\001\025\001\025\001\025\000\234\001Q\000\000\000\000\000\000\000\000\000\000\001\025\001\025\001\025\001\025\001\025\001\025\000\000\003J\000\242\001\025\000\138\001\129\001\129\000\000\000\000\001\129\001\129\000\000\000\146\000\162\001N\000\133\001\129\000\000\000\000\000\154\000\170\000\250\001Q\000\186\000\178\000\194\000\202\001\129\000\210\000\000\001\129\001\129\001\129\000\218\001\129\000\226\001\129\001\129\001\129\001\129\001\002\000\234\000\000\000\029\000\000\000\000\000\000\000\000\000\133\000\000\001\129\001\129\000\000\000\026\000\000\000\000\000\242\001\129\000\138\000&\000*\000\000\000\000\000.\0016\000\000\000\146\000\162\002u\001I\001:\000\000\000\000\000\154\003\018\000\250\0006\000\186\000\178\003\026\000\202\000>\000\210\000\000\000B\001F\000\018\000\218\001j\000\226\001r\000F\000J\001\162\001\002\000\234\000\000\000\000\000\000\000\000\000\000\000\000\002u\000\000\000N\001\166\000\000\000\245\000\245\000\245\000\242\001\230\000\245\000\245\000\000\000\146\000\162\000\245\000\245\000\245\000\000\000\000\000\154\000\170\000\245\000\245\000\000\000\178\000\194\000\000\000\245\000\000\000\000\000\245\000\245\000\245\000\000\000\245\000\000\000\245\000\245\000\245\000\245\000\245\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\245\000\245\000\245\000\245\000\245\000\245\000\000\000\000\000\245\000\245\001\t\001\t\001\t\000\000\000\000\001\t\001\t\000\000\000\146\000\162\001\t\001\t\001\t\000\000\000\000\000\154\000\170\001\t\001\t\000\000\000\178\000\194\000\000\001\t\000\000\000\000\001\t\001\t\001\t\000\000\001\t\000\000\001\t\001\t\001\t\001\t\001\t\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\t\001\t\001\t\001\t\001\t\001\t\000\000\000\000\001\t\001\t\000\253\000\253\000\253\000\000\000\000\000\253\000\253\000\000\000\146\000\162\000\253\000\253\000\253\000\000\000\000\000\154\000\170\000\253\000\253\000\000\000\178\000\194\000\000\000\253\000\000\000\000\000\253\000\253\000\253\000\000\000\253\000\000\000\253\000\253\000\253\000\253\000\253\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\253\000\253\000\253\000\253\000\253\000\253\000\000\000\000\000\253\000\253\000\249\000\249\000\249\000\000\000\000\000\249\000\249\000\000\000\146\000\162\000\249\000\249\000\249\000\000\000\000\000\154\000\170\000\249\000\249\000\000\000\178\000\194\000\000\000\249\000\000\000\000\000\249\000\249\000\249\000\000\000\249\000\000\000\249\000\249\000\249\000\249\000\249\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\249\000\249\000\249\000\249\000\249\000\249\000\000\000\000\000\249\000\249\001\005\001\005\001\005\000\000\000\000\001\005\001\005\000\000\000\146\000\162\001\005\001\005\001\005\000\000\000\000\000\154\000\170\001\005\001\005\000\000\000\178\000\194\000\000\001\005\000\000\000\000\001\005\001\005\001\005\000\000\001\005\000\000\001\005\001\005\001\005\001\005\001\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\005\001\005\001\005\001\005\001\005\001\005\000\000\000\000\001\005\001\005\001\001\001\001\001\001\000\000\000\000\001\001\001\001\000\000\000\146\000\162\001\001\001\001\001\001\000\000\000\000\000\154\000\170\001\001\001\001\000\000\000\178\000\194\000\000\001\001\000\000\000\000\001\001\001\001\001\001\000\000\001\001\000\000\001\001\001\001\001\001\001\001\001\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\001\001\001\001\001\001\001\001\001\001\001\000\000\000\000\001\001\001\001\001\129\001\129\001\193\001\173\001\129\001\129\000\000\000\000\000\000\000\000\001]\001\129\000\014\001\173\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\129\000\000\001\173\001\129\001\129\000\018\000\000\001\129\000\000\001\129\001\129\001\129\001\129\000\000\000\000\001\193\000\000\000\000\000\000\000\000\000\022\003R\001]\001\129\001\129\000\000\000\026\000\138\000\000\000\217\001\129\000\000\000\217\000\000\000\000\000\146\000\162\000\217\001\022\000\000\000\000\000\000\000\154\000\170\000\250\000\217\000\186\000\178\000\194\000\202\000\217\000\210\000\000\000\217\000\000\000\217\000\218\000\000\000\226\000\000\000\217\000\217\000\000\001\002\000\234\000\000\000\000\000\138\000\000\000\213\000\000\000\217\000\213\000\217\000\000\000\146\000\162\000\213\000\000\000\242\000\000\000\000\000\154\000\170\000\250\000\213\000\186\000\178\000\194\000\202\000\213\000\210\000\000\000\213\000\000\000\213\000\218\000\000\000\226\000\000\000\213\000\213\000\000\001\002\000\234\000\193\000\193\000\193\000\193\000\193\000\193\000\213\000\000\000\213\000\000\000\000\000\193\000\193\000\193\000\242\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\193\000\000\000\193\000\193\000\193\000\193\000\000\000\193\000\000\000\193\000\193\000\193\000\193\000\000\000\000\000\193\000\193\001V\000\000\000\000\000\193\000\000\000\000\000\193\000\193\000\000\000\193\000\000\000\000\000\000\000\193\001\237\001\237\001\237\001\237\001\237\001\237\000\000\000\000\000\000\000\000\000\000\001\237\001\237\001\237\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\237\000\000\001\237\001\237\001\237\001\237\000\000\001\237\000\000\001\237\001\237\001\237\001\237\000\000\000\000\001\237\000\000\000\000\000\000\000\000\001\237\000\000\000\000\001\237\001\237\000\000\003\130\000\000\002%\002%\001\237\002%\002%\002%\000\006\000\000\000\000\000\000\000\000\002%\002%\002%\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002%\000\000\002%\002%\002%\002%\000\000\002%\000\000\002%\002%\002%\002%\000\000\000\000\002%\000\000\000\000\000\000\000\000\002%\000\000\000\000\002%\002%\000\000\002%\000\241\000y\000y\002%\001\173\000y\000y\000\000\000\146\000\162\000\000\000\137\000y\000\014\000\000\000\154\000\241\000\241\000\000\000\241\000\178\000\241\000\241\000y\000\241\001\173\000y\000y\000\018\000\241\000y\000\241\000y\000y\000y\000y\000\241\000\241\000\000\000y\000\000\000\000\000\000\000\022\000\137\000\241\000y\000y\000\000\000y\000\138\000%\000\241\000y\000\000\000\000\000\000\000\000\000\146\000\162\000%\0009\000\000\000\000\000\000\000\154\000\170\000\250\000\000\000\186\000\178\000\194\000\202\000\000\000\210\000\000\000\000\000\000\000\000\000\218\000\000\000\226\000\000\000\000\000\000\000\000\001\002\000\234\000\000\000\000\000\000\000\000\000\000\000\000\0009\000\138\000)\000\000\001\130\000\000\000\000\000\000\000\242\000\146\000\162\000)\001\029\000\000\000\000\000\000\000\154\000\170\000\250\000\000\000\186\000\178\000\194\000\202\000\000\000\210\003\166\000\000\000\000\000\000\000\218\000\181\000\226\000\000\000\000\001\129\001\129\001\002\000\234\001\129\001\129\000\000\000\000\000\000\000\000\001\n\001\129\003\170\000\000\003\174\000\000\000\000\000\000\000\242\003\178\000\000\000\000\001\129\000\000\000\000\001\129\001\129\001\129\000\000\001\129\000\181\001\129\001\129\001\129\001\129\000\000\000\000\000\000\000\021\000\000\000\000\000\t\000\241\000\000\000\000\001\129\001\129\000\000\000\026\000\000\000\146\000\162\001\129\000=\002.\000\000\000\000\000\154\000\241\000\241\000\000\000\241\000\178\000\241\000\241\000\000\000\241\000\000\001\225\000\000\000\000\000\241\001\225\000\241\000\000\000\t\002\130\000\000\000\241\000\241\000\138\000\000\001\225\000\000\000\000\000\000\000=\000\241\000\146\000\162\000\000\000\129\000\000\000\000\000\241\000\154\000\170\000\250\000\000\000\186\000\178\002\186\000\202\000\000\000\210\000\000\000\000\000\000\000\000\000\218\000\000\000\226\000\000\000\000\000\000\000\000\001\002\000\234\000\138\000\000\000\000\000\000\000\000\000\000\000\129\002\194\000\146\000\162\000\000\0005\000\000\000\000\000\242\000\154\000\170\000\250\000\000\000\186\000\178\001\194\000\202\000\000\000\210\000\000\000\000\000\000\000\000\000\218\000\000\000\226\000\000\000\000\000\000\000\000\001\002\000\234\000\138\000\000\000\000\000\000\000\000\000\000\0005\001\202\000\146\000\162\0011\000\000\000\000\000\000\000\242\000\154\000\170\000\250\000\000\000\186\000\178\000\194\000\202\000\000\000\210\000\000\000\000\000\000\000\000\000\218\000\000\000\226\000\000\000\000\000\000\000\000\001\002\000\234\000\138\000\000\000\000\000\000\000\000\000\000\0011\000\000\000\146\000\162\000\017\000\000\000\000\000\000\000\242\000\154\000\170\000\250\000\000\000\186\000\178\000\194\000\202\000\000\000\210\000\000\000\000\000\000\000\000\000\218\000\000\000\226\000\000\000\000\000\000\000\000\001\002\000\234\000\138\000\000\000\000\000\000\000\000\000\000\000\017\000\000\000\146\000\162\001y\000\000\000\000\000\000\000\242\000\154\000\170\000\250\000\000\000\186\000\178\000\194\000\202\000\000\000\210\000\000\000\000\000\000\000\000\000\218\000\000\000\226\000\000\000\000\000\000\000\000\001\002\000\234\000\138\000\000\000\000\000\000\000\000\000\000\001y\000\000\000\146\000\162\001*\000\000\000\000\000\000\000\242\000\154\000\170\000\250\000\000\000\186\000\178\000\194\000\202\000\000\000\210\000\138\000\000\000\000\000\000\000\218\000\000\000\226\000\000\000\146\000\162\002\133\001\002\000\234\000\000\000\000\000\154\000\170\000\250\000\000\000\186\000\178\000\194\000\202\000\000\000\210\000\138\000\000\000\242\000\000\000\218\000\000\000\226\000\000\000\146\000\162\001\174\001\002\000\234\000\000\000\000\000\154\000\170\000\250\000\000\000\186\000\178\000\194\000\202\000\000\000\210\000\000\000\000\000\242\000\000\000\218\000\000\000\226\000*\000\000\000\000\000.\001\002\000\234\002\178\000\000\001u\000\149\000\000\000\000\000\000\000\000\0002\000\000\0006\000\000\000\000\000:\000\242\000>\000\000\000\000\000B\000\000\000\018\000*\000\000\000\000\000.\000F\000J\000\000\000\000\002u\001%\000\000\000\000\000\000\001\186\0002\001u\0006\000N\000\000\000:\000\000\000>\000*\000\000\000B\000.\000\018\000\000\000\000\000\000\001-\000F\000J\000\000\000\000\000\000\0002\000\000\0006\000\000\000\000\000:\002u\000>\000N\000\000\000B\000\000\000\018\000\000\000\000\000\000\000\000\000F\000J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001-\000\000\000N"))
  
  and lhs =
    (8, "\000GFFEDDCCBBA@@@@??>==<<;:99888766665544333322110//.--------------------,,++**)(('&%%$$#\"\"\"!  \031\031\030\029\029\028\028\028\028\028\028\027\026\026\025\025\025\024\024\023\022\022\021\021\020\020\020\019\019\019\018\018\017\016\016\016\015\015\014\r\r\r\012\012\011\011\n\n\n\n\n\t\t\t\t\t\t\t\b\b\007\006\005\005\004\004\003\002\002\001")
  
  and goto =
    ((16, "\000\r\000\002\000\134\000\000\000\000\000\000\001\254\000\026\000\003\001\212\000\000\000\000\002F\001\248\002j\003\030\000\000\000\000\000\000\000\000\000\000\000\000\000\230\000\000\001\132\000\000\000\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\210\000\000\002\172\000\000\002\142\000\000\003\204\000\000\001\218\000\000\003\168\000\000\003<\000\000\002\028\000\000\003f\000\000\001\174\000\000\003\024\000\000\002\208\000\000\001\182\000\000\002\178\000\000\002\250\000\000\003B\000\000\0010\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\186\000\000\000\000\000\000\001N\000\000\000\000\002d\000\150\0008\000\021\000\015\000\000\000\000\001T\000\000\001\130\000\000\001\136\000\000\003\174\001H\001\254\000\000\001\222\002@\000\000\000\000\001&\000\000\000\000\002\214\000\000\000\000\001*\000#\000\000\000\000\003\240\000\000\002\"\000\000\000\000\001l\000\000\000\000\000D\000\000\000\000\000\000\000$\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\136\000\000\000\000\001\028\000\000\000\000\000\150\000\242\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\186\000\000\000\000\000\000\000Z\000\000\000\000\000\000\000\150\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001$\001\130\000r\000\000\000\000\002\244\000\000\003\132\000\000\000\000\000\000\000\000\000\000\000\198\000\000\0010\000\000\000\152\001R\000b\001Z\001\"\000\000\000\000\001T\000\000\001\152\003\138\000\000\003`\000\000\000\000\000\196\000\000\000\000\000\000\000\000\000\252\000\000\000p\000V\001 \000\128\000 \000\000\000\000\000d\001,\000\000\000\000\000\000\000\000\000\000\000\138\001z\000\002\000%\000\000\000@\000<\001\144\001\166\000\000\000\158\000\000\000\000\000\000\000\000\000l\000\000\000\000\000\000\000X\000\000\000\000\000\000\000\158\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"), (16, "\000{\000W\000\021\000\022\000\024\000\003\000|\000\227\000}\000\158\001\001\000\029\000\003\000\130\000\226\000\233\000\030\001\002\000\021\000\022\000\131\000\b\000\t\000\128\000\253\000\132\000\135\000\029\000p\000\159\000\244\000\138\000\160\000\230\000\144\000{\000U\000X\000\145\000\245\000\028\000|\000\t\000}\000\129\000\146\000u\000\151\000\130\000\212\000\214\000M\000\190\000\021\000\022\000\131\000\246\000\t\000\147\000\239\000\132\000\135\000\029\000\194\000\148\000\229\000\138\000\139\000\149\000\144\000\150\000M\000\219\000\145\000\224\000\166\000\021\000\022\000\024\000\223\000\146\000\162\000\194\000Y\000\167\000\029\000M\000\b\000\202\000\210\000\030\000\168\000\169\000\147\000\243\000\241\000\t\000\212\000\215\000\148\000\233\000L\000\174\000\149\000\t\000\150\000\157\000\156\000\t\000\179\000\181\000\182\000\021\000\022\000\024\000\250\000\204\000\206\000\021\000\022\000\024\000\029\000\t\000\251\000\252\000M\000\030\000\029\000\238\000\240\000\241\000\208\000\030\000M\000\021\000\022\000\024\000M\000p\000\203\000\021\000\022\000\024\000\029\000\174\000\143\000\247\000\165\000\030\000\029\000\192\000M\000\184\000\182\000\030\000h\000\153\000\151\000\031\000!\000\"\000\021\000\022\000\131\000\141\000!\000\"\000\207\000\137\000\135\000\029\000\021\000\022\000\024\000\195\000\030\000\t\000\212\000\216\000\171\000\029\000\220\000\222\000\212\000\218\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\021\000\022\000\024\000\029\000D\000\"\000\029\000\185\000\030\000\029\000\189\000\030\000\191\000M\000\030\000\249\000\201\000P\000\154\000\156\000Q\000\021\000\026\000\196\000\232\000Z\000\193\000\021\000\022\000\024\000\029\000\021\000\022\000\024\000\\\000\030\000\029\000^\000c\000\231\000\029\000\030\000\021\000\022\000\024\000\030\000\021\000\022\000\024\000f\000y\000\029\000\000\000\193\000\000\000\029\000\030\000\196\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\0006\000\000\000\029\000\b\000<\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000J\000\029\000\000\000,\000\029\000\t\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000H\000\029\000\000\000b\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000M\000\000\0002\000\029\000\000\000t\000\029\000\000\000\030\000\163\000\165\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000e\000\029\000\000\000I\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000S\000\029\000\000\000G\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000\134\000\029\000\000\000(\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000&\000\029\000\000\000>\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000:\000\029\000\000\000k\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000\176\000\029\000\000\000@\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\0008\000\029\000\000\000E\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\0000\000\029\000\000\000B\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000\200\000\029\000\000\0004\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000\178\000\029\000\000\000\198\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\021\000\022\000\024\000\000\000\000\000.\000\029\000\000\000`\000\029\000\000\000\030\000\000\000\000\000\030\000\021\000\022\000\024\000\000\000\000\000\000\000\000\000\000\000*\000\029\000\000\000$\000\000\000\000\000\030\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000r"))
  
  and semantic_action =
    [|
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v =
          let _endpos = _endpos__1_ in
          let _startpos = _startpos__1_ in
          (
# 445 "lib/parser.mly"
      (
        let callee = nid _startpos _endpos "ABORT" in
        n _startpos _endpos (Ast.SCallStmt { callee; args = [] })
      )
# 409 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.expr Ast.node list) = 
# 465 "lib/parser.mly"
                ( [] )
# 428 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = es;
            MenhirLib.EngineTypes.startp = _startpos_es_;
            MenhirLib.EngineTypes.endp = _endpos_es_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let es : (Ast.expr Ast.node list) = Obj.magic es in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Ast.expr Ast.node list) = 
# 466 "lib/parser.mly"
                                   ( es )
# 467 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhses;
              MenhirLib.EngineTypes.startp = _startpos_lhses_;
              MenhirLib.EngineTypes.endp = _endpos_lhses_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhses : (Ast.expr Ast.node list) = Obj.magic lhses in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhses_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhses_ in
          (
# 411 "lib/parser.mly"
      (
        match lhses with
        | [lhs] -> n _startpos _endpos (Ast.SAssign { lhs; rhs })
        | _ ->
            let assigns =
              List.map (fun lhs -> Ast.node ~loc:(loc _startpos _endpos) (Ast.SAssign { lhs; rhs })) lhses
            in
            mk_block _startpos _endpos assigns
      )
# 517 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node list) = 
# 380 "lib/parser.mly"
                ( [s] )
# 543 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = ss;
          MenhirLib.EngineTypes.startp = _startpos_ss_;
          MenhirLib.EngineTypes.endp = _endpos_ss_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = s;
            MenhirLib.EngineTypes.startp = _startpos_s_;
            MenhirLib.EngineTypes.endp = _endpos_s_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let ss : (Ast.stmt Ast.node list) = Obj.magic ss in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_ss_ in
        let _v : (Ast.stmt Ast.node list) = 
# 381 "lib/parser.mly"
                              ( s :: ss )
# 575 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.stmt Ast.node list) = 
# 375 "lib/parser.mly"
                ( [] )
# 593 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = ss;
          MenhirLib.EngineTypes.startp = _startpos_ss_;
          MenhirLib.EngineTypes.endp = _endpos_ss_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let ss : (Ast.stmt Ast.node list) = Obj.magic ss in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_ss_ in
        let _endpos = _endpos_ss_ in
        let _v : (Ast.stmt Ast.node list) = 
# 376 "lib/parser.mly"
                  ( ss )
# 618 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.expr Ast.node option) = 
# 519 "lib/parser.mly"
                ( None )
# 636 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (Ast.expr Ast.node) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v : (Ast.expr Ast.node option) = 
# 520 "lib/parser.mly"
                ( Some e )
# 668 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = args;
          MenhirLib.EngineTypes.startp = _startpos_args_;
          MenhirLib.EngineTypes.endp = _endpos_args_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = callee;
            MenhirLib.EngineTypes.startp = _startpos_callee_;
            MenhirLib.EngineTypes.endp = _endpos_callee_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let args : (Ast.expr Ast.node list) = Obj.magic args in
        let callee : (Ast.ident) = Obj.magic callee in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_callee_ in
        let _endpos = _endpos_args_ in
        let _v =
          let _endpos = _endpos_args_ in
          let _startpos = _startpos_callee_ in
          (
# 461 "lib/parser.mly"
      ( n _startpos _endpos (Ast.SCallStmt { callee; args }) )
# 703 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v =
          let _endpos = _endpos__1_ in
          let _startpos = _startpos__1_ in
          (
# 557 "lib/parser.mly"
            ( n _startpos _endpos (Ast.EName (nid _startpos _endpos "DEFAULT")) )
# 732 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let e : (Ast.expr Ast.node) = Obj.magic e in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e_ in
        let _endpos = _endpos_e_ in
        let _v : (Ast.expr Ast.node) = 
# 558 "lib/parser.mly"
            ( e )
# 758 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = hi;
          MenhirLib.EngineTypes.startp = _startpos_hi_;
          MenhirLib.EngineTypes.endp = _endpos_hi_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lo;
              MenhirLib.EngineTypes.startp = _startpos_lo_;
              MenhirLib.EngineTypes.endp = _endpos_lo_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let hi : (Ast.expr Ast.node) = Obj.magic hi in
        let _2 : unit = Obj.magic _2 in
        let lo : (Ast.expr Ast.node) = Obj.magic lo in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lo_ in
        let _endpos = _endpos_hi_ in
        let _v =
          let _endpos = _endpos_hi_ in
          let _startpos = _startpos_lo_ in
          (
# 560 "lib/parser.mly"
      (
        let callee = nid _startpos _endpos "__range__" in
        n _startpos _endpos (Ast.ECall { callee; args = [lo; hi] })
      )
# 803 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = hi;
          MenhirLib.EngineTypes.startp = _startpos_hi_;
          MenhirLib.EngineTypes.endp = _endpos_hi_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lo;
              MenhirLib.EngineTypes.startp = _startpos_lo_;
              MenhirLib.EngineTypes.endp = _endpos_lo_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let hi : (Ast.expr Ast.node) = Obj.magic hi in
        let _2 : unit = Obj.magic _2 in
        let lo : (Ast.expr Ast.node) = Obj.magic lo in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lo_ in
        let _endpos = _endpos_hi_ in
        let _v =
          let _endpos = _endpos_hi_ in
          let _startpos = _startpos_lo_ in
          (
# 565 "lib/parser.mly"
      (
        let callee = nid _startpos _endpos "__range__" in
        n _startpos _endpos (Ast.ECall { callee; args = [lo; hi] })
      )
# 849 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = i;
          MenhirLib.EngineTypes.startp = _startpos_i_;
          MenhirLib.EngineTypes.endp = _endpos_i_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let i : (Ast.expr Ast.node) = Obj.magic i in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_i_ in
        let _endpos = _endpos_i_ in
        let _v : (Ast.expr Ast.node list) = 
# 552 "lib/parser.mly"
                 ( [i] )
# 875 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = is;
          MenhirLib.EngineTypes.startp = _startpos_is_;
          MenhirLib.EngineTypes.endp = _endpos_is_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = i;
              MenhirLib.EngineTypes.startp = _startpos_i_;
              MenhirLib.EngineTypes.endp = _endpos_i_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let is : (Ast.expr Ast.node list) = Obj.magic is in
        let _2 : unit = Obj.magic _2 in
        let i : (Ast.expr Ast.node) = Obj.magic i in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_i_ in
        let _endpos = _endpos_is_ in
        let _v : (Ast.expr Ast.node list) = 
# 553 "lib/parser.mly"
                                          ( i :: is )
# 914 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = body;
          MenhirLib.EngineTypes.startp = _startpos_body_;
          MenhirLib.EngineTypes.endp = _endpos_body_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _sep;
            MenhirLib.EngineTypes.startp = _startpos__sep_;
            MenhirLib.EngineTypes.endp = _endpos__sep_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = idxs;
                MenhirLib.EngineTypes.startp = _startpos_idxs_;
                MenhirLib.EngineTypes.endp = _endpos_idxs_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let body : (Ast.stmt Ast.node) = Obj.magic body in
        let _sep : (unit) = Obj.magic _sep in
        let _3 : unit = Obj.magic _3 in
        let idxs : (Ast.expr Ast.node list) = Obj.magic idxs in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_body_ in
        let _v : (Ast.expr Ast.node list * Ast.stmt Ast.node) = 
# 543 "lib/parser.mly"
      ( (idxs, body) )
# 967 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Ast.expr Ast.node list * Ast.stmt Ast.node) list) = 
# 537 "lib/parser.mly"
                ( [] )
# 985 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = os;
          MenhirLib.EngineTypes.startp = _startpos_os_;
          MenhirLib.EngineTypes.endp = _endpos_os_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = o;
            MenhirLib.EngineTypes.startp = _startpos_o_;
            MenhirLib.EngineTypes.endp = _endpos_o_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let os : ((Ast.expr Ast.node list * Ast.stmt Ast.node) list) = Obj.magic os in
        let o : (Ast.expr Ast.node list * Ast.stmt Ast.node) = Obj.magic o in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_o_ in
        let _endpos = _endpos_os_ in
        let _v : ((Ast.expr Ast.node list * Ast.stmt Ast.node) list) = 
# 538 "lib/parser.mly"
                                  ( o :: os )
# 1017 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) = 
# 547 "lib/parser.mly"
          ( () )
# 1042 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) = 
# 548 "lib/parser.mly"
          ( () )
# 1067 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _6;
          MenhirLib.EngineTypes.startp = _startpos__6_;
          MenhirLib.EngineTypes.endp = _endpos__6_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = opts;
            MenhirLib.EngineTypes.startp = _startpos_opts_;
            MenhirLib.EngineTypes.endp = _endpos_opts_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = _3;
                MenhirLib.EngineTypes.startp = _startpos__3_;
                MenhirLib.EngineTypes.endp = _endpos__3_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _;
                  MenhirLib.EngineTypes.semv = _scrut;
                  MenhirLib.EngineTypes.startp = _startpos__scrut_;
                  MenhirLib.EngineTypes.endp = _endpos__scrut_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = _1;
                    MenhirLib.EngineTypes.startp = _startpos__1_;
                    MenhirLib.EngineTypes.endp = _endpos__1_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _6 : unit = Obj.magic _6 in
        let opts : ((Ast.expr Ast.node list * Ast.stmt Ast.node) list) = Obj.magic opts in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let _scrut : (Ast.expr Ast.node) = Obj.magic _scrut in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__6_ in
        let _v =
          let _endpos = _endpos__6_ in
          let _startpos = _startpos__1_ in
          (
# 530 "lib/parser.mly"
      ( 
        let bodies = List.map snd opts in
        mk_block _startpos _endpos bodies
      )
# 1133 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = ss;
            MenhirLib.EngineTypes.startp = _startpos_ss_;
            MenhirLib.EngineTypes.endp = _endpos_ss_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let ss : (Ast.stmt Ast.node list) = Obj.magic ss in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v =
          let _endpos = _endpos__3_ in
          let _startpos = _startpos__1_ in
          (
# 371 "lib/parser.mly"
      ( mk_block _startpos _endpos ss )
# 1176 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _t;
          MenhirLib.EngineTypes.startp = _startpos__t_;
          MenhirLib.EngineTypes.endp = _endpos__t_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = init;
            MenhirLib.EngineTypes.startp = _startpos_init_;
            MenhirLib.EngineTypes.endp = _endpos_init_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = ty;
              MenhirLib.EngineTypes.startp = _startpos_ty_;
              MenhirLib.EngineTypes.endp = _endpos_ty_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = nm;
                MenhirLib.EngineTypes.startp = _startpos_nm_;
                MenhirLib.EngineTypes.endp = _endpos_nm_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _;
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = mod_;
                    MenhirLib.EngineTypes.startp = _startpos_mod__;
                    MenhirLib.EngineTypes.endp = _endpos_mod__;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _t : (unit) = Obj.magic _t in
        let init : (Ast.expr Ast.node option) = Obj.magic init in
        let ty : (Ast.type_expr Ast.node) = Obj.magic ty in
        let nm : (Ast.ident) = Obj.magic nm in
        let _2 : unit = Obj.magic _2 in
        let mod_ : (string option) = Obj.magic mod_ in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_mod__ in
        let _endpos = _endpos__t_ in
        let _v =
          let _endpos = _endpos__t_ in
          let _startpos = _startpos_mod__ in
          (
# 141 "lib/parser.mly"
      (
        let storage =
          match mod_ with
          | None -> Ast.Automatic
          | Some _ -> Ast.External
        in
        let var =
          n _startpos _endpos
            (Ast.DVar { name = nm; dtype = ty; init; storage })
        in
        match mod_ with
        | None -> [var]
        | Some m ->
            let md =
              n _startpos_mod__ _endpos_mod__
                (Ast.DDirective {
                  name = nid _startpos_mod__ _endpos_mod__ m;
                  args = [nid _startpos_nm_ _endpos_nm_ nm.v];
                })
            in
            [md; var]
      )
# 1261 "lib/parser.ml"
           : (Ast.decl Ast.node list))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _t;
          MenhirLib.EngineTypes.startp = _startpos__t_;
          MenhirLib.EngineTypes.endp = _endpos__t_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = recopt;
            MenhirLib.EngineTypes.startp = _startpos_recopt_;
            MenhirLib.EngineTypes.endp = _endpos_recopt_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = dims;
              MenhirLib.EngineTypes.startp = _startpos_dims_;
              MenhirLib.EngineTypes.endp = _endpos_dims_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = nm;
                MenhirLib.EngineTypes.startp = _startpos_nm_;
                MenhirLib.EngineTypes.endp = _endpos_nm_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _;
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = mod_;
                    MenhirLib.EngineTypes.startp = _startpos_mod__;
                    MenhirLib.EngineTypes.endp = _endpos_mod__;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let _t : (unit) = Obj.magic _t in
        let recopt : (Ast.field_decl Ast.node list option) = Obj.magic recopt in
        let dims : (Ast.expr Ast.node list) = Obj.magic dims in
        let nm : (Ast.ident) = Obj.magic nm in
        let _2 : unit = Obj.magic _2 in
        let mod_ : (string option) = Obj.magic mod_ in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_mod__ in
        let _endpos = _endpos__t_ in
        let _v =
          let _endpos = _endpos__t_ in
          let _startpos = _startpos_mod__ in
          (
# 166 "lib/parser.mly"
      (
        let storage =
          match mod_ with
          | None -> Ast.Automatic
          | Some _ -> Ast.External
        in
        let elem_ty =
          match recopt with
          | None ->
              n _startpos _endpos (Ast.TName (nid _startpos _endpos "__table_elem__"))
          | Some fields ->
              n _startpos _endpos (Ast.TRecord fields)
        in
        let ty = n _startpos _endpos (Ast.TArray { elem = elem_ty; dims }) in
        let var = n _startpos _endpos (Ast.DVar { name = nm; dtype = ty; init = None; storage }) in
        match mod_ with
        | None -> [var]
        | Some m ->
            let md =
              n _startpos_mod__ _endpos_mod__
                (Ast.DDirective {
                  name = nid _startpos_mod__ _endpos_mod__ m;
                  args = [nid _startpos_nm_ _endpos_nm_ nm.v];
                })
            in
            [md; var]
      )
# 1351 "lib/parser.ml"
           : (Ast.decl Ast.node list))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = d;
          MenhirLib.EngineTypes.startp = _startpos_d_;
          MenhirLib.EngineTypes.endp = _endpos_d_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let d : (Ast.decl Ast.node) = Obj.magic d in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_d_ in
        let _endpos = _endpos_d_ in
        let _v : (Ast.decl Ast.node list) = 
# 97 "lib/parser.mly"
                     ( [d] )
# 1377 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = ds;
          MenhirLib.EngineTypes.startp = _startpos_ds_;
          MenhirLib.EngineTypes.endp = _endpos_ds_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let ds : (Ast.decl Ast.node list) = Obj.magic ds in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_ds_ in
        let _endpos = _endpos_ds_ in
        let _v : (Ast.decl Ast.node list) = 
# 98 "lib/parser.mly"
                     ( ds )
# 1402 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = ds;
          MenhirLib.EngineTypes.startp = _startpos_ds_;
          MenhirLib.EngineTypes.endp = _endpos_ds_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let ds : (Ast.decl Ast.node list) = Obj.magic ds in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_ds_ in
        let _endpos = _endpos_ds_ in
        let _v : (Ast.decl Ast.node list) = 
# 99 "lib/parser.mly"
                     ( ds )
# 1427 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let xs : (Ast.decl Ast.node list list) = Obj.magic xs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_xs_ in
        let _endpos = _endpos_xs_ in
        let _v : (Ast.decl Ast.node list) = 
# 342 "lib/parser.mly"
                        ( List.concat (List.rev xs) )
# 1452 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v =
          let _endpos = _endpos__1_ in
          let _startpos = _startpos__1_ in
          (
# 215 "lib/parser.mly"
         ( n _startpos _endpos (Ast.EName (nid _startpos _endpos "*")) )
# 1480 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let e : (Ast.expr Ast.node) = Obj.magic e in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e_ in
        let _endpos = _endpos_e_ in
        let _v : (Ast.expr Ast.node) = 
# 216 "lib/parser.mly"
           ( e )
# 1506 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = hi;
          MenhirLib.EngineTypes.startp = _startpos_hi_;
          MenhirLib.EngineTypes.endp = _endpos_hi_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lo;
              MenhirLib.EngineTypes.startp = _startpos_lo_;
              MenhirLib.EngineTypes.endp = _endpos_lo_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let hi : (Ast.expr Ast.node) = Obj.magic hi in
        let _2 : unit = Obj.magic _2 in
        let lo : (Ast.expr Ast.node) = Obj.magic lo in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lo_ in
        let _endpos = _endpos_hi_ in
        let _v =
          let _endpos = _endpos_hi_ in
          let _startpos = _startpos_lo_ in
          (
# 218 "lib/parser.mly"
      (
        let callee = nid _startpos _endpos "__range__" in
        n _startpos _endpos (Ast.ECall { callee; args = [lo; hi] })
      )
# 1551 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = hi;
          MenhirLib.EngineTypes.startp = _startpos_hi_;
          MenhirLib.EngineTypes.endp = _endpos_hi_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lo;
              MenhirLib.EngineTypes.startp = _startpos_lo_;
              MenhirLib.EngineTypes.endp = _endpos_lo_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let hi : (Ast.expr Ast.node) = Obj.magic hi in
        let _2 : unit = Obj.magic _2 in
        let lo : (Ast.expr Ast.node) = Obj.magic lo in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lo_ in
        let _endpos = _endpos_hi_ in
        let _v =
          let _endpos = _endpos_hi_ in
          let _startpos = _startpos_lo_ in
          (
# 223 "lib/parser.mly"
      (
        let callee = nid _startpos _endpos "__range__" in
        n _startpos _endpos (Ast.ECall { callee; args = [lo; hi] })
      )
# 1597 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = d;
          MenhirLib.EngineTypes.startp = _startpos_d_;
          MenhirLib.EngineTypes.endp = _endpos_d_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let d : (Ast.expr Ast.node) = Obj.magic d in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_d_ in
        let _endpos = _endpos_d_ in
        let _v : (Ast.expr Ast.node list) = 
# 210 "lib/parser.mly"
          ( [d] )
# 1623 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rest;
          MenhirLib.EngineTypes.startp = _startpos_rest_;
          MenhirLib.EngineTypes.endp = _endpos_rest_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = d;
              MenhirLib.EngineTypes.startp = _startpos_d_;
              MenhirLib.EngineTypes.endp = _endpos_d_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rest : (Ast.expr Ast.node list) = Obj.magic rest in
        let _2 : unit = Obj.magic _2 in
        let d : (Ast.expr Ast.node) = Obj.magic d in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_d_ in
        let _endpos = _endpos_rest_ in
        let _v : (Ast.expr Ast.node list) = 
# 211 "lib/parser.mly"
                              ( d :: rest )
# 1662 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.expr Ast.node list) = 
# 205 "lib/parser.mly"
                ( [] )
# 1680 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = ds;
          MenhirLib.EngineTypes.startp = _startpos_ds_;
          MenhirLib.EngineTypes.endp = _endpos_ds_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let ds : (Ast.expr Ast.node list) = Obj.magic ds in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_ds_ in
        let _endpos = _endpos_ds_ in
        let _v : (Ast.expr Ast.node list) = 
# 206 "lib/parser.mly"
                ( ds )
# 1705 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (
# 28 "lib/parser.mly"
       (string)
# 1726 "lib/parser.ml"
        ) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v =
          let _endpos = _endpos_s_ in
          let _startpos = _startpos_s_ in
          (
# 130 "lib/parser.mly"
                ( nid _startpos _endpos s )
# 1737 "lib/parser.ml"
           : (string Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = i;
          MenhirLib.EngineTypes.startp = _startpos_i_;
          MenhirLib.EngineTypes.endp = _endpos_i_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let i : (
# 26 "lib/parser.mly"
       (string)
# 1759 "lib/parser.ml"
        ) = Obj.magic i in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_i_ in
        let _endpos = _endpos_i_ in
        let _v =
          let _endpos = _endpos_i_ in
          let _startpos = _startpos_i_ in
          (
# 131 "lib/parser.mly"
                ( nid _startpos _endpos i )
# 1770 "lib/parser.ml"
           : (string Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = f;
          MenhirLib.EngineTypes.startp = _startpos_f_;
          MenhirLib.EngineTypes.endp = _endpos_f_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let f : (
# 27 "lib/parser.mly"
       (string)
# 1792 "lib/parser.ml"
        ) = Obj.magic f in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_f_ in
        let _endpos = _endpos_f_ in
        let _v =
          let _endpos = _endpos_f_ in
          let _startpos = _startpos_f_ in
          (
# 132 "lib/parser.mly"
                ( nid _startpos _endpos f )
# 1803 "lib/parser.ml"
           : (string Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = id;
          MenhirLib.EngineTypes.startp = _startpos_id_;
          MenhirLib.EngineTypes.endp = _endpos_id_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let id : (
# 25 "lib/parser.mly"
       (string)
# 1825 "lib/parser.ml"
        ) = Obj.magic id in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_id_ in
        let _endpos = _endpos_id_ in
        let _v =
          let _endpos = _endpos_id_ in
          let _startpos = _startpos_id_ in
          (
# 133 "lib/parser.mly"
                ( nid _startpos _endpos id )
# 1836 "lib/parser.ml"
           : (string Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = a;
          MenhirLib.EngineTypes.startp = _startpos_a_;
          MenhirLib.EngineTypes.endp = _endpos_a_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let a : (string Ast.node) = Obj.magic a in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_a_ in
        let _endpos = _endpos_a_ in
        let _v : (string Ast.node list) = 
# 125 "lib/parser.mly"
                    ( [a] )
# 1862 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rest;
          MenhirLib.EngineTypes.startp = _startpos_rest_;
          MenhirLib.EngineTypes.endp = _endpos_rest_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = a;
              MenhirLib.EngineTypes.startp = _startpos_a_;
              MenhirLib.EngineTypes.endp = _endpos_a_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rest : (string Ast.node list) = Obj.magic rest in
        let _2 : unit = Obj.magic _2 in
        let a : (string Ast.node) = Obj.magic a in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_a_ in
        let _endpos = _endpos_rest_ in
        let _v : (string Ast.node list) = 
# 126 "lib/parser.mly"
                                              ( a :: rest )
# 1901 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (string Ast.node list) = 
# 120 "lib/parser.mly"
                ( [] )
# 1919 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = args;
          MenhirLib.EngineTypes.startp = _startpos_args_;
          MenhirLib.EngineTypes.endp = _endpos_args_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let args : (string Ast.node list) = Obj.magic args in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_args_ in
        let _endpos = _endpos_args_ in
        let _v : (string Ast.node list) = 
# 121 "lib/parser.mly"
                        ( args )
# 1944 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _t;
          MenhirLib.EngineTypes.startp = _startpos__t_;
          MenhirLib.EngineTypes.endp = _endpos__t_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = args;
            MenhirLib.EngineTypes.startp = _startpos_args_;
            MenhirLib.EngineTypes.endp = _endpos_args_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = name;
              MenhirLib.EngineTypes.startp = _startpos_name_;
              MenhirLib.EngineTypes.endp = _endpos_name_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _t : (unit) = Obj.magic _t in
        let args : (string Ast.node list) = Obj.magic args in
        let name : (Ast.ident) = Obj.magic name in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_name_ in
        let _endpos = _endpos__t_ in
        let _v =
          let _endpos = _endpos__t_ in
          let _startpos = _startpos_name_ in
          (
# 113 "lib/parser.mly"
      (
        let d = Ast.DDirective { name; args } in
        n _startpos _endpos d
      )
# 1989 "lib/parser.ml"
           : (Ast.decl Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.stmt Ast.node option) = 
# 489 "lib/parser.mly"
                ( None )
# 2008 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node option) = 
# 490 "lib/parser.mly"
                     ( Some s )
# 2040 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v =
          let _endpos = _endpos__1_ in
          let _startpos = _startpos__1_ in
          (
# 437 "lib/parser.mly"
      (
        let callee = nid _startpos _endpos "EXIT" in
        n _startpos _endpos (Ast.SCallStmt { callee; args = [] })
      )
# 2071 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let e : (Ast.expr Ast.node) = Obj.magic e in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e_ in
        let _endpos = _endpos_e_ in
        let _v : (Ast.expr Ast.node) = 
# 624 "lib/parser.mly"
              ( e )
# 2097 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos__1_ in
          (
# 627 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EUnop { op = Ast.UNot; rhs }) )
# 2132 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos__1_ in
          (
# 630 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EUnop { op = Ast.UPlus; rhs }) )
# 2168 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos__1_ in
          (
# 633 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EUnop { op = Ast.UMinus; rhs }) )
# 2204 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 636 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BMul; lhs; rhs }) )
# 2247 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 639 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BMul; lhs; rhs }) )
# 2290 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 642 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BDiv; lhs; rhs }) )
# 2333 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 645 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BMod; lhs; rhs }) )
# 2376 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 648 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BAdd; lhs; rhs }) )
# 2419 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 651 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BSub; lhs; rhs }) )
# 2462 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 654 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BLt; lhs; rhs }) )
# 2505 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 657 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BLe; lhs; rhs }) )
# 2548 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 660 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BGt; lhs; rhs }) )
# 2591 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 663 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BGe; lhs; rhs }) )
# 2634 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 666 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BEq; lhs; rhs }) )
# 2677 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 669 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BNe; lhs; rhs }) )
# 2720 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 672 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BAnd; lhs; rhs }) )
# 2763 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 675 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BOr; lhs; rhs }) )
# 2806 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 678 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BBitXor; lhs; rhs }) )
# 2849 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rhs;
          MenhirLib.EngineTypes.startp = _startpos_rhs_;
          MenhirLib.EngineTypes.endp = _endpos_rhs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = lhs;
              MenhirLib.EngineTypes.startp = _startpos_lhs_;
              MenhirLib.EngineTypes.endp = _endpos_lhs_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let rhs : (Ast.expr Ast.node) = Obj.magic rhs in
        let _2 : unit = Obj.magic _2 in
        let lhs : (Ast.expr Ast.node) = Obj.magic lhs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lhs_ in
        let _endpos = _endpos_rhs_ in
        let _v =
          let _endpos = _endpos_rhs_ in
          let _startpos = _startpos_lhs_ in
          (
# 681 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EBinop { op = Ast.BBitXor; lhs; rhs }) )
# 2892 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let e : (Ast.expr Ast.node) = Obj.magic e in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e_ in
        let _endpos = _endpos_e_ in
        let _v : (Ast.expr Ast.node list) = 
# 475 "lib/parser.mly"
           ( [e] )
# 2918 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = es;
          MenhirLib.EngineTypes.startp = _startpos_es_;
          MenhirLib.EngineTypes.endp = _endpos_es_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = e;
              MenhirLib.EngineTypes.startp = _startpos_e_;
              MenhirLib.EngineTypes.endp = _endpos_e_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let es : (Ast.expr Ast.node list) = Obj.magic es in
        let _2 : unit = Obj.magic _2 in
        let e : (Ast.expr Ast.node) = Obj.magic e in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e_ in
        let _endpos = _endpos_es_ in
        let _v : (Ast.expr Ast.node list) = 
# 476 "lib/parser.mly"
                              ( e :: es )
# 2957 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.expr Ast.node list) = 
# 470 "lib/parser.mly"
                ( [] )
# 2975 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = es;
          MenhirLib.EngineTypes.startp = _startpos_es_;
          MenhirLib.EngineTypes.endp = _endpos_es_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let es : (Ast.expr Ast.node list) = Obj.magic es in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_es_ in
        let _endpos = _endpos_es_ in
        let _v : (Ast.expr Ast.node list) = 
# 471 "lib/parser.mly"
                 ( es )
# 3000 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.expr Ast.node option) = 
# 576 "lib/parser.mly"
                ( None )
# 3018 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let e : (Ast.expr Ast.node) = Obj.magic e in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e_ in
        let _endpos = _endpos_e_ in
        let _v : (Ast.expr Ast.node option) = 
# 577 "lib/parser.mly"
                ( Some e )
# 3043 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _t;
          MenhirLib.EngineTypes.startp = _startpos__t_;
          MenhirLib.EngineTypes.endp = _endpos__t_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _init;
            MenhirLib.EngineTypes.startp = _startpos__init_;
            MenhirLib.EngineTypes.endp = _endpos__init_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = ty;
              MenhirLib.EngineTypes.startp = _startpos_ty_;
              MenhirLib.EngineTypes.endp = _endpos_ty_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = nm;
                MenhirLib.EngineTypes.startp = _startpos_nm_;
                MenhirLib.EngineTypes.endp = _endpos_nm_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let _t : (unit) = Obj.magic _t in
        let _init : (Ast.expr Ast.node option) = Obj.magic _init in
        let ty : (Ast.type_expr Ast.node) = Obj.magic ty in
        let nm : (Ast.ident) = Obj.magic nm in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__t_ in
        let _v =
          let _endpos = _endpos__t_ in
          let _startpos = _startpos__1_ in
          (
# 246 "lib/parser.mly"
      ( n _startpos _endpos { Ast.fname = nm; ftype = ty } )
# 3099 "lib/parser.ml"
           : (Ast.field_decl Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.field_decl Ast.node list) = 
# 235 "lib/parser.mly"
                ( [] )
# 3118 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let xs : (Ast.field_decl Ast.node list) = Obj.magic xs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_xs_ in
        let _endpos = _endpos_xs_ in
        let _v : (Ast.field_decl Ast.node list) = 
# 236 "lib/parser.mly"
                           ( List.rev xs )
# 3143 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = body;
          MenhirLib.EngineTypes.startp = _startpos_body_;
          MenhirLib.EngineTypes.endp = _endpos_body_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _7;
            MenhirLib.EngineTypes.startp = _startpos__7_;
            MenhirLib.EngineTypes.endp = _endpos__7_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = wh;
              MenhirLib.EngineTypes.startp = _startpos_wh_;
              MenhirLib.EngineTypes.endp = _endpos_wh_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = by;
                MenhirLib.EngineTypes.startp = _startpos_by_;
                MenhirLib.EngineTypes.endp = _endpos_by_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _;
                  MenhirLib.EngineTypes.semv = initv;
                  MenhirLib.EngineTypes.startp = _startpos_initv_;
                  MenhirLib.EngineTypes.endp = _endpos_initv_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _;
                    MenhirLib.EngineTypes.semv = _3;
                    MenhirLib.EngineTypes.startp = _startpos__3_;
                    MenhirLib.EngineTypes.endp = _endpos__3_;
                    MenhirLib.EngineTypes.next = {
                      MenhirLib.EngineTypes.state = _;
                      MenhirLib.EngineTypes.semv = lc;
                      MenhirLib.EngineTypes.startp = _startpos_lc_;
                      MenhirLib.EngineTypes.endp = _endpos_lc_;
                      MenhirLib.EngineTypes.next = {
                        MenhirLib.EngineTypes.state = _menhir_s;
                        MenhirLib.EngineTypes.semv = _1;
                        MenhirLib.EngineTypes.startp = _startpos__1_;
                        MenhirLib.EngineTypes.endp = _endpos__1_;
                        MenhirLib.EngineTypes.next = _menhir_stack;
                      };
                    };
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let body : (Ast.stmt Ast.node) = Obj.magic body in
        let _7 : unit = Obj.magic _7 in
        let wh : (Ast.expr Ast.node option) = Obj.magic wh in
        let by : (Ast.expr Ast.node option) = Obj.magic by in
        let initv : (Ast.expr Ast.node) = Obj.magic initv in
        let _3 : unit = Obj.magic _3 in
        let lc : (Ast.ident) = Obj.magic lc in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_body_ in
        let _v =
          let _endpos = _endpos_body_ in
          let _startpos = _startpos__1_ in
          (
# 500 "lib/parser.mly"
      (
        let lhs = n _startpos_lc_ _endpos_lc_ (Ast.EName lc) in
        let init_stmt = n _startpos _endpos (Ast.SAssign { lhs; rhs = initv }) in

        let step_stmt =
          match by with
          | None -> None
          | Some inc ->
              let rhs =
                n _startpos _endpos (Ast.EBinop { op = Ast.BAdd; lhs; rhs = inc })
              in
              Some (n _startpos _endpos (Ast.SAssign { lhs; rhs }))
        in

        n _startpos _endpos (Ast.SFor { init = Some init_stmt; cond = wh; step = step_stmt; body })
      )
# 3235 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = outs;
          MenhirLib.EngineTypes.startp = _startpos_outs_;
          MenhirLib.EngineTypes.endp = _endpos_outs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = ins;
            MenhirLib.EngineTypes.startp = _startpos_ins_;
            MenhirLib.EngineTypes.endp = _endpos_ins_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let outs : (Ast.ident list) = Obj.magic outs in
        let ins : (Ast.ident list) = Obj.magic ins in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_ins_ in
        let _endpos = _endpos_outs_ in
        let _v =
          let _endpos = _endpos_outs_ in
          let _startpos = _startpos_ins_ in
          (
# 308 "lib/parser.mly"
      (
        let unknown_ty =
          n _startpos _endpos (Ast.TName (nid _startpos _endpos "__implicit__"))
        in
        let mkp mode (id : Ast.ident) =
          Ast.node ~loc:id.loc { Ast.pname = id; pmode = mode; ptype = unknown_ty }
        in
        let ins_ps = List.map (mkp Ast.In) ins in
        let outs_ps = List.map (mkp Ast.Out) outs in
        ins_ps @ outs_ps
      )
# 3281 "lib/parser.ml"
           : (Ast.param Ast.node list))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.param Ast.node list) = 
# 302 "lib/parser.mly"
                ( [] )
# 3300 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = ps;
          MenhirLib.EngineTypes.startp = _startpos_ps_;
          MenhirLib.EngineTypes.endp = _endpos_ps_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let ps : (Ast.param Ast.node list) = Obj.magic ps in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_ps_ in
        let _endpos = _endpos_ps_ in
        let _v : (Ast.param Ast.node list) = 
# 303 "lib/parser.mly"
                           ( ps )
# 3325 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.param Ast.node list) = 
# 297 "lib/parser.mly"
                ( [] )
# 3343 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = ps;
            MenhirLib.EngineTypes.startp = _startpos_ps_;
            MenhirLib.EngineTypes.endp = _endpos_ps_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let ps : (Ast.param Ast.node list) = Obj.magic ps in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Ast.param Ast.node list) = 
# 298 "lib/parser.mly"
                                             ( ps )
# 3382 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = nm;
          MenhirLib.EngineTypes.startp = _startpos_nm_;
          MenhirLib.EngineTypes.endp = _endpos_nm_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let nm : (Ast.ident) = Obj.magic nm in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_nm_ in
        let _v =
          let _endpos = _endpos_nm_ in
          let _startpos = _startpos__1_ in
          (
# 428 "lib/parser.mly"
                  ( n _startpos _endpos (Ast.SGoto nm) )
# 3417 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Ast.ident) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Ast.ident list) = 
# 327 "lib/parser.mly"
            ( [x] )
# 3443 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (Ast.ident list) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : (Ast.ident) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Ast.ident list) = 
# 328 "lib/parser.mly"
                             ( x :: xs )
# 3482 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x;
            MenhirLib.EngineTypes.startp = _startpos_x_;
            MenhirLib.EngineTypes.endp = _endpos_x_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let xs : (Ast.ident list) = Obj.magic xs in
        let x : (Ast.ident) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Ast.ident list) = 
# 329 "lib/parser.mly"
                       ( x :: xs )
# 3514 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (
# 25 "lib/parser.mly"
       (string)
# 3535 "lib/parser.ml"
        ) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v =
          let _endpos = _endpos_s_ in
          let _startpos = _startpos_s_ in
          (
# 581 "lib/parser.mly"
         ( nid _startpos _endpos s )
# 3546 "lib/parser.ml"
           : (Ast.ident))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = else_;
          MenhirLib.EngineTypes.startp = _startpos_else__;
          MenhirLib.EngineTypes.endp = _endpos_else__;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = then_;
            MenhirLib.EngineTypes.startp = _startpos_then__;
            MenhirLib.EngineTypes.endp = _endpos_then__;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _3;
              MenhirLib.EngineTypes.startp = _startpos__3_;
              MenhirLib.EngineTypes.endp = _endpos__3_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = test;
                MenhirLib.EngineTypes.startp = _startpos_test_;
                MenhirLib.EngineTypes.endp = _endpos_test_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _menhir_s;
                  MenhirLib.EngineTypes.semv = _1;
                  MenhirLib.EngineTypes.startp = _startpos__1_;
                  MenhirLib.EngineTypes.endp = _endpos__1_;
                  MenhirLib.EngineTypes.next = _menhir_stack;
                };
              };
            };
          };
        } = _menhir_stack in
        let else_ : (Ast.stmt Ast.node option) = Obj.magic else_ in
        let then_ : (Ast.stmt Ast.node) = Obj.magic then_ in
        let _3 : unit = Obj.magic _3 in
        let test : (Ast.expr Ast.node) = Obj.magic test in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_else__ in
        let _v =
          let _endpos = _endpos_else__ in
          let _startpos = _startpos__1_ in
          (
# 483 "lib/parser.mly"
      ( n _startpos _endpos (Ast.SIf { cond = test; then_; else_ }) )
# 3603 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = else_;
          MenhirLib.EngineTypes.startp = _startpos_else__;
          MenhirLib.EngineTypes.endp = _endpos_else__;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = then_;
            MenhirLib.EngineTypes.startp = _startpos_then__;
            MenhirLib.EngineTypes.endp = _endpos_then__;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = test;
              MenhirLib.EngineTypes.startp = _startpos_test_;
              MenhirLib.EngineTypes.endp = _endpos_test_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let else_ : (Ast.stmt Ast.node option) = Obj.magic else_ in
        let then_ : (Ast.stmt Ast.node) = Obj.magic then_ in
        let test : (Ast.expr Ast.node) = Obj.magic test in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_else__ in
        let _v =
          let _endpos = _endpos_else__ in
          let _startpos = _startpos__1_ in
          (
# 485 "lib/parser.mly"
      ( n _startpos _endpos (Ast.SIf { cond = test; then_; else_ }) )
# 3653 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.expr Ast.node option) = 
# 196 "lib/parser.mly"
                ( None )
# 3672 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let e : (Ast.expr Ast.node) = Obj.magic e in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_e_ in
        let _endpos = _endpos_e_ in
        let _v : (Ast.expr Ast.node option) = 
# 197 "lib/parser.mly"
                ( Some e )
# 3697 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = nm;
            MenhirLib.EngineTypes.startp = _startpos_nm_;
            MenhirLib.EngineTypes.endp = _endpos_nm_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let nm : (Ast.ident) = Obj.magic nm in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_nm_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast.ident) = 
# 366 "lib/parser.mly"
                   ( nm )
# 3729 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.ident list) = 
# 361 "lib/parser.mly"
                ( [] )
# 3747 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = l;
          MenhirLib.EngineTypes.startp = _startpos_l_;
          MenhirLib.EngineTypes.endp = _endpos_l_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = labs;
            MenhirLib.EngineTypes.startp = _startpos_labs_;
            MenhirLib.EngineTypes.endp = _endpos_labs_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let l : (Ast.ident) = Obj.magic l in
        let labs : (Ast.ident list) = Obj.magic labs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_labs_ in
        let _endpos = _endpos_l_ in
        let _v : (Ast.ident list) = 
# 362 "lib/parser.mly"
                            ( labs @ [l] )
# 3779 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = i;
          MenhirLib.EngineTypes.startp = _startpos_i_;
          MenhirLib.EngineTypes.endp = _endpos_i_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let i : (
# 26 "lib/parser.mly"
       (string)
# 3800 "lib/parser.ml"
        ) = Obj.magic i in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_i_ in
        let _endpos = _endpos_i_ in
        let _v : (Ast.literal) = 
# 585 "lib/parser.mly"
                ( Ast.LInt i )
# 3808 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = f;
          MenhirLib.EngineTypes.startp = _startpos_f_;
          MenhirLib.EngineTypes.endp = _endpos_f_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let f : (
# 27 "lib/parser.mly"
       (string)
# 3829 "lib/parser.ml"
        ) = Obj.magic f in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_f_ in
        let _endpos = _endpos_f_ in
        let _v : (Ast.literal) = 
# 586 "lib/parser.mly"
                ( Ast.LFloat f )
# 3837 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (
# 28 "lib/parser.mly"
       (string)
# 3858 "lib/parser.ml"
        ) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.literal) = 
# 587 "lib/parser.mly"
                ( Ast.LString s )
# 3866 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = c;
          MenhirLib.EngineTypes.startp = _startpos_c_;
          MenhirLib.EngineTypes.endp = _endpos_c_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let c : (
# 29 "lib/parser.mly"
       (char)
# 3887 "lib/parser.ml"
        ) = Obj.magic c in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_c_ in
        let _endpos = _endpos_c_ in
        let _v : (Ast.literal) = 
# 588 "lib/parser.mly"
                ( Ast.LChar c )
# 3895 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Ast.literal) = 
# 589 "lib/parser.mly"
                ( Ast.LBool true )
# 3920 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Ast.literal) = 
# 590 "lib/parser.mly"
                ( Ast.LBool false )
# 3945 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = p;
          MenhirLib.EngineTypes.startp = _startpos_p_;
          MenhirLib.EngineTypes.endp = _endpos_p_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let p : (Ast.expr Ast.node) = Obj.magic p in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_p_ in
        let _endpos = _endpos_p_ in
        let _v : (Ast.expr Ast.node) = 
# 620 "lib/parser.mly"
              ( p )
# 3970 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Ast.expr Ast.node) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Ast.expr Ast.node list) = 
# 423 "lib/parser.mly"
             ( [x] )
# 3995 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (Ast.expr Ast.node list) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : (Ast.expr Ast.node) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Ast.expr Ast.node list) = 
# 424 "lib/parser.mly"
                                  ( x :: xs )
# 4034 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (string option) = 
# 103 "lib/parser.mly"
                ( None )
# 4052 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string option) = 
# 104 "lib/parser.mly"
                ( Some "DEF" )
# 4077 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (string option) = 
# 105 "lib/parser.mly"
                ( Some "REF" )
# 4102 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = ds;
          MenhirLib.EngineTypes.startp = _startpos_ds_;
          MenhirLib.EngineTypes.endp = _endpos_ds_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let ds : (Ast.decl Ast.node list) = Obj.magic ds in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_ds_ in
        let _endpos = _endpos_ds_ in
        let _v : (Ast.toplevel list) = 
# 88 "lib/parser.mly"
                     ( List.map (fun d -> Ast.TopDecl d) ds )
# 4127 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.toplevel list) = 
# 89 "lib/parser.mly"
                     ( [Ast.TopStmt s] )
# 4152 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let xs : (Ast.toplevel list list) = Obj.magic xs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_xs_ in
        let _endpos = _endpos_xs_ in
        let _v : (Ast.program) = 
# 79 "lib/parser.mly"
                        ( List.concat (List.rev xs) )
# 4177 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.ident list) = 
# 322 "lib/parser.mly"
                ( [] )
# 4195 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = outs;
          MenhirLib.EngineTypes.startp = _startpos_outs_;
          MenhirLib.EngineTypes.endp = _endpos_outs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let outs : (Ast.ident list) = Obj.magic outs in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_outs_ in
        let _v : (Ast.ident list) = 
# 323 "lib/parser.mly"
                       ( outs )
# 4227 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = p;
          MenhirLib.EngineTypes.startp = _startpos_p_;
          MenhirLib.EngineTypes.endp = _endpos_p_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let p : (Ast.expr Ast.node) = Obj.magic p in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_p_ in
        let _endpos = _endpos_p_ in
        let _v : (Ast.expr Ast.node) = 
# 614 "lib/parser.mly"
                   ( p )
# 4252 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = ptr;
          MenhirLib.EngineTypes.startp = _startpos_ptr_;
          MenhirLib.EngineTypes.endp = _endpos_ptr_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = field;
              MenhirLib.EngineTypes.startp = _startpos_field_;
              MenhirLib.EngineTypes.endp = _endpos_field_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let ptr : (Ast.expr Ast.node) = Obj.magic ptr in
        let _2 : unit = Obj.magic _2 in
        let field : (Ast.expr Ast.node) = Obj.magic field in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_field_ in
        let _endpos = _endpos_ptr_ in
        let _v =
          let _endpos = _endpos_ptr_ in
          let _startpos = _startpos_field_ in
          (
# 616 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EAt { field; ptr }) )
# 4294 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = p;
          MenhirLib.EngineTypes.startp = _startpos_p_;
          MenhirLib.EngineTypes.endp = _endpos_p_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let p : (Ast.expr Ast.node) = Obj.magic p in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_p_ in
        let _endpos = _endpos_p_ in
        let _v : (Ast.expr Ast.node) = 
# 600 "lib/parser.mly"
              ( p )
# 4320 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = fld;
          MenhirLib.EngineTypes.startp = _startpos_fld_;
          MenhirLib.EngineTypes.endp = _endpos_fld_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = base;
              MenhirLib.EngineTypes.startp = _startpos_base_;
              MenhirLib.EngineTypes.endp = _endpos_base_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let fld : (Ast.ident) = Obj.magic fld in
        let _2 : unit = Obj.magic _2 in
        let base : (Ast.expr Ast.node) = Obj.magic base in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_base_ in
        let _endpos = _endpos_fld_ in
        let _v =
          let _endpos = _endpos_fld_ in
          let _startpos = _startpos_base_ in
          (
# 602 "lib/parser.mly"
      ( n _startpos _endpos (Ast.EField { base; field = fld }) )
# 4362 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = args;
            MenhirLib.EngineTypes.startp = _startpos_args_;
            MenhirLib.EngineTypes.endp = _endpos_args_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = base;
                MenhirLib.EngineTypes.startp = _startpos_base_;
                MenhirLib.EngineTypes.endp = _endpos_base_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let args : (Ast.expr Ast.node list) = Obj.magic args in
        let _2 : unit = Obj.magic _2 in
        let base : (Ast.expr Ast.node) = Obj.magic base in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_base_ in
        let _endpos = _endpos__4_ in
        let _v =
          let _endpos = _endpos__4_ in
          let _startpos = _startpos_base_ in
          (
# 604 "lib/parser.mly"
      (
        match base.v with
        | Ast.EName callee ->
            n _startpos _endpos (Ast.ECall { callee; args })
        | _ ->
            n _startpos _endpos (Ast.EIndex { base; index = args })
      )
# 4418 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = id;
          MenhirLib.EngineTypes.startp = _startpos_id_;
          MenhirLib.EngineTypes.endp = _endpos_id_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let id : (Ast.ident) = Obj.magic id in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_id_ in
        let _endpos = _endpos_id_ in
        let _v =
          let _endpos = _endpos_id_ in
          let _startpos = _startpos_id_ in
          (
# 594 "lib/parser.mly"
             ( n _startpos _endpos (Ast.EName id) )
# 4447 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = lit;
          MenhirLib.EngineTypes.startp = _startpos_lit_;
          MenhirLib.EngineTypes.endp = _endpos_lit_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let lit : (Ast.literal) = Obj.magic lit in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_lit_ in
        let _endpos = _endpos_lit_ in
        let _v =
          let _endpos = _endpos_lit_ in
          let _startpos = _startpos_lit_ in
          (
# 595 "lib/parser.mly"
                ( n _startpos _endpos (Ast.ELit lit) )
# 4476 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = e;
            MenhirLib.EngineTypes.startp = _startpos_e_;
            MenhirLib.EngineTypes.endp = _endpos_e_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let e : (Ast.expr Ast.node) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v =
          let _endpos = _endpos__3_ in
          let _startpos = _startpos__1_ in
          (
# 596 "lib/parser.mly"
                         ( n _startpos _endpos (Ast.EParen e) )
# 4519 "lib/parser.ml"
           : (Ast.expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Ast.decl Ast.node list * Ast.stmt Ast.node) option) = 
# 333 "lib/parser.mly"
                ( None )
# 4538 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = ss;
            MenhirLib.EngineTypes.startp = _startpos_ss_;
            MenhirLib.EngineTypes.endp = _endpos_ss_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = ds;
              MenhirLib.EngineTypes.startp = _startpos_ds_;
              MenhirLib.EngineTypes.endp = _endpos_ds_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let ss : (Ast.stmt Ast.node list) = Obj.magic ss in
        let ds : (Ast.decl Ast.node list) = Obj.magic ds in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v =
          let _endpos = _endpos__4_ in
          let _startpos = _startpos__1_ in
          (
# 335 "lib/parser.mly"
      (
        let body = mk_block _startpos _endpos ss in
        Some (ds, body)
      )
# 4590 "lib/parser.ml"
           : ((Ast.decl Ast.node list * Ast.stmt Ast.node) option))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = body;
          MenhirLib.EngineTypes.startp = _startpos_body_;
          MenhirLib.EngineTypes.endp = _endpos_body_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _t;
            MenhirLib.EngineTypes.startp = _startpos__t_;
            MenhirLib.EngineTypes.endp = _endpos__t_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = formals;
              MenhirLib.EngineTypes.startp = _startpos_formals_;
              MenhirLib.EngineTypes.endp = _endpos_formals_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _;
                MenhirLib.EngineTypes.semv = nm;
                MenhirLib.EngineTypes.startp = _startpos_nm_;
                MenhirLib.EngineTypes.endp = _endpos_nm_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.state = _;
                  MenhirLib.EngineTypes.semv = _2;
                  MenhirLib.EngineTypes.startp = _startpos__2_;
                  MenhirLib.EngineTypes.endp = _endpos__2_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = mod_;
                    MenhirLib.EngineTypes.startp = _startpos_mod__;
                    MenhirLib.EngineTypes.endp = _endpos_mod__;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let body : ((Ast.decl Ast.node list * Ast.stmt Ast.node) option) = Obj.magic body in
        let _t : (unit) = Obj.magic _t in
        let formals : (Ast.param Ast.node list) = Obj.magic formals in
        let nm : (Ast.ident) = Obj.magic nm in
        let _2 : unit = Obj.magic _2 in
        let mod_ : (string option) = Obj.magic mod_ in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_mod__ in
        let _endpos = _endpos_body_ in
        let _v =
          let _endpos = _endpos_body_ in
          let _startpos = _startpos_mod__ in
          (
# 270 "lib/parser.mly"
      (
        let params = formals in
        let locals, body_stmt =
          match body with
          | None -> ([], mk_block _startpos _endpos [])
          | Some (ds, st) -> (ds, st)
        in
        let proc =
          n _startpos _endpos
            { Ast.name = nm; params; returns = None; locals; body = body_stmt }
        in
        let dproc = n _startpos _endpos (Ast.DProc proc) in
        match mod_ with
        | None -> [dproc]
        | Some m ->
            let md =
              n _startpos_mod__ _endpos_mod__
                (Ast.DDirective {
                  name = nid _startpos_mod__ _endpos_mod__ m;
                  args = [nid _startpos_nm_ _endpos_nm_ nm.v];
                })
            in
            [md; dproc]
      )
# 4677 "lib/parser.ml"
           : (Ast.decl Ast.node list))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = items;
              MenhirLib.EngineTypes.startp = _startpos_items_;
              MenhirLib.EngineTypes.endp = _endpos_items_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let _3 : unit = Obj.magic _3 in
        let items : (Ast.program) = Obj.magic items in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Ast.program) = 
# 73 "lib/parser.mly"
                                      ( items )
# 4724 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = items;
            MenhirLib.EngineTypes.startp = _startpos_items_;
            MenhirLib.EngineTypes.endp = _endpos_items_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let items : (Ast.program) = Obj.magic items in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_items_ in
        let _endpos = _endpos__2_ in
        let _v : (Ast.program) = 
# 74 "lib/parser.mly"
                                      ( items )
# 4756 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = items;
            MenhirLib.EngineTypes.startp = _startpos_items_;
            MenhirLib.EngineTypes.endp = _endpos_items_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let items : (Ast.program) = Obj.magic items in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Ast.program) = 
# 75 "lib/parser.mly"
                                      ( items )
# 4795 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.field_decl Ast.node list option) = 
# 230 "lib/parser.mly"
                ( None )
# 4813 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _4;
          MenhirLib.EngineTypes.startp = _startpos__4_;
          MenhirLib.EngineTypes.endp = _endpos__4_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = fs;
            MenhirLib.EngineTypes.startp = _startpos_fs_;
            MenhirLib.EngineTypes.endp = _endpos_fs_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let _4 : unit = Obj.magic _4 in
        let fs : (Ast.field_decl Ast.node list) = Obj.magic fs in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__4_ in
        let _v : (Ast.field_decl Ast.node list option) = 
# 231 "lib/parser.mly"
                                       ( Some fs )
# 4859 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = eo;
          MenhirLib.EngineTypes.startp = _startpos_eo_;
          MenhirLib.EngineTypes.endp = _endpos_eo_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let eo : (Ast.expr Ast.node option) = Obj.magic eo in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_eo_ in
        let _v =
          let _endpos = _endpos_eo_ in
          let _startpos = _startpos__1_ in
          (
# 432 "lib/parser.mly"
                       ( n _startpos _endpos (Ast.SReturn eo) )
# 4894 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.decl Ast.node list list) = 
# 346 "lib/parser.mly"
                ( [] )
# 4913 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = ds;
          MenhirLib.EngineTypes.startp = _startpos_ds_;
          MenhirLib.EngineTypes.endp = _endpos_ds_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = xs;
            MenhirLib.EngineTypes.startp = _startpos_xs_;
            MenhirLib.EngineTypes.endp = _endpos_xs_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let ds : (Ast.decl Ast.node list) = Obj.magic ds in
        let xs : (Ast.decl Ast.node list list) = Obj.magic xs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_xs_ in
        let _endpos = _endpos_ds_ in
        let _v : (Ast.decl Ast.node list list) = 
# 347 "lib/parser.mly"
                                     ( ds :: xs )
# 4945 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = d;
          MenhirLib.EngineTypes.startp = _startpos_d_;
          MenhirLib.EngineTypes.endp = _endpos_d_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = xs;
            MenhirLib.EngineTypes.startp = _startpos_xs_;
            MenhirLib.EngineTypes.endp = _endpos_xs_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let d : (Ast.decl Ast.node) = Obj.magic d in
        let xs : (Ast.decl Ast.node list list) = Obj.magic xs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_xs_ in
        let _endpos = _endpos_d_ in
        let _v : (Ast.decl Ast.node list list) = 
# 348 "lib/parser.mly"
                                         ( [d] :: xs )
# 4977 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = f;
          MenhirLib.EngineTypes.startp = _startpos_f_;
          MenhirLib.EngineTypes.endp = _endpos_f_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let f : (Ast.field_decl Ast.node) = Obj.magic f in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_f_ in
        let _endpos = _endpos_f_ in
        let _v : (Ast.field_decl Ast.node list) = 
# 240 "lib/parser.mly"
                 ( [f] )
# 5002 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = f;
          MenhirLib.EngineTypes.startp = _startpos_f_;
          MenhirLib.EngineTypes.endp = _endpos_f_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = xs;
            MenhirLib.EngineTypes.startp = _startpos_xs_;
            MenhirLib.EngineTypes.endp = _endpos_xs_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let f : (Ast.field_decl Ast.node) = Obj.magic f in
        let xs : (Ast.field_decl Ast.node list) = Obj.magic xs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_xs_ in
        let _endpos = _endpos_f_ in
        let _v : (Ast.field_decl Ast.node list) = 
# 241 "lib/parser.mly"
                                        ( f :: xs )
# 5034 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.toplevel list list) = 
# 83 "lib/parser.mly"
                ( [] )
# 5052 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = xs;
            MenhirLib.EngineTypes.startp = _startpos_xs_;
            MenhirLib.EngineTypes.endp = _endpos_xs_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let x : (Ast.toplevel list) = Obj.magic x in
        let xs : (Ast.toplevel list list) = Obj.magic xs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_xs_ in
        let _endpos = _endpos_x_ in
        let _v : (Ast.toplevel list list) = 
# 84 "lib/parser.mly"
                                      ( x :: xs )
# 5084 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 385 "lib/parser.mly"
                    ( s )
# 5109 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 386 "lib/parser.mly"
                    ( s )
# 5134 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 387 "lib/parser.mly"
                    ( s )
# 5159 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 388 "lib/parser.mly"
                    ( s )
# 5184 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _t;
          MenhirLib.EngineTypes.startp = _startpos__t_;
          MenhirLib.EngineTypes.endp = _endpos__t_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = s;
            MenhirLib.EngineTypes.startp = _startpos_s_;
            MenhirLib.EngineTypes.endp = _endpos_s_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _t : (unit) = Obj.magic _t in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos__t_ in
        let _v : (Ast.stmt Ast.node) = 
# 389 "lib/parser.mly"
                                ( s )
# 5216 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 400 "lib/parser.mly"
                  ( s )
# 5241 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 401 "lib/parser.mly"
                  ( s )
# 5266 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 402 "lib/parser.mly"
                  ( s )
# 5291 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 403 "lib/parser.mly"
                  ( s )
# 5316 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 404 "lib/parser.mly"
                  ( s )
# 5341 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 405 "lib/parser.mly"
                  ( s )
# 5366 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 406 "lib/parser.mly"
                  ( s )
# 5391 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 356 "lib/parser.mly"
                    ( s )
# 5416 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = s;
          MenhirLib.EngineTypes.startp = _startpos_s_;
          MenhirLib.EngineTypes.endp = _endpos_s_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = labs;
            MenhirLib.EngineTypes.startp = _startpos_labs_;
            MenhirLib.EngineTypes.endp = _endpos_labs_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let s : (Ast.stmt Ast.node) = Obj.magic s in
        let labs : (Ast.ident list) = Obj.magic labs in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_labs_ in
        let _endpos = _endpos_s_ in
        let _v : (Ast.stmt Ast.node) = 
# 357 "lib/parser.mly"
                                             ( wrap_labels labs s )
# 5448 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v =
          let _endpos = _endpos__1_ in
          let _startpos = _startpos__1_ in
          (
# 453 "lib/parser.mly"
      (
        let callee = nid _startpos _endpos "STOP" in
        n _startpos _endpos (Ast.SCallStmt { callee; args = [] })
      )
# 5479 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = _3;
          MenhirLib.EngineTypes.startp = _startpos__3_;
          MenhirLib.EngineTypes.endp = _endpos__3_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = ds;
            MenhirLib.EngineTypes.startp = _startpos_ds_;
            MenhirLib.EngineTypes.endp = _endpos_ds_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _3 : unit = Obj.magic _3 in
        let ds : (Ast.expr Ast.node list) = Obj.magic ds in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__3_ in
        let _v : (Ast.expr Ast.node list) = 
# 201 "lib/parser.mly"
                                  ( ds )
# 5519 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) = 
# 393 "lib/parser.mly"
         ( () )
# 5544 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) = 
# 394 "lib/parser.mly"
          ( () )
# 5569 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.expr Ast.node list) = 
# 262 "lib/parser.mly"
                ( [] )
# 5587 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = rest;
          MenhirLib.EngineTypes.startp = _startpos_rest_;
          MenhirLib.EngineTypes.endp = _endpos_rest_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = s;
            MenhirLib.EngineTypes.startp = _startpos_s_;
            MenhirLib.EngineTypes.endp = _endpos_s_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let rest : (Ast.expr Ast.node list) = Obj.magic rest in
        let s : (Ast.expr Ast.node) = Obj.magic s in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_s_ in
        let _endpos = _endpos_rest_ in
        let _v : (Ast.expr Ast.node list) = 
# 263 "lib/parser.mly"
                               ( s :: rest )
# 5619 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = sizes;
          MenhirLib.EngineTypes.startp = _startpos_sizes_;
          MenhirLib.EngineTypes.endp = _endpos_sizes_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = base;
            MenhirLib.EngineTypes.startp = _startpos_base_;
            MenhirLib.EngineTypes.endp = _endpos_base_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let sizes : (Ast.expr Ast.node list) = Obj.magic sizes in
        let base : (Ast.ident) = Obj.magic base in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_base_ in
        let _endpos = _endpos_sizes_ in
        let _v =
          let _endpos = _endpos_sizes_ in
          let _startpos = _startpos_base_ in
          (
# 252 "lib/parser.mly"
      (
        match sizes with
        | [] -> n _startpos _endpos (Ast.TName base)
        | dims ->
            let elem = n _startpos_base_ _endpos_base_ (Ast.TName base) in
            n _startpos _endpos (Ast.TArray { elem; dims })
      )
# 5660 "lib/parser.ml"
           : (Ast.type_expr Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Ast.expr Ast.node option) = 
# 524 "lib/parser.mly"
                ( None )
# 5679 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = e;
          MenhirLib.EngineTypes.startp = _startpos_e_;
          MenhirLib.EngineTypes.endp = _endpos_e_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let e : (Ast.expr Ast.node) = Obj.magic e in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_e_ in
        let _v : (Ast.expr Ast.node option) = 
# 525 "lib/parser.mly"
                 ( Some e )
# 5711 "lib/parser.ml"
         in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _;
          MenhirLib.EngineTypes.semv = body;
          MenhirLib.EngineTypes.startp = _startpos_body_;
          MenhirLib.EngineTypes.endp = _endpos_body_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _;
            MenhirLib.EngineTypes.semv = _3;
            MenhirLib.EngineTypes.startp = _startpos__3_;
            MenhirLib.EngineTypes.endp = _endpos__3_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _;
              MenhirLib.EngineTypes.semv = cond;
              MenhirLib.EngineTypes.startp = _startpos_cond_;
              MenhirLib.EngineTypes.endp = _endpos_cond_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = _1;
                MenhirLib.EngineTypes.startp = _startpos__1_;
                MenhirLib.EngineTypes.endp = _endpos__1_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let body : (Ast.stmt Ast.node) = Obj.magic body in
        let _3 : unit = Obj.magic _3 in
        let cond : (Ast.expr Ast.node) = Obj.magic cond in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_body_ in
        let _v =
          let _endpos = _endpos_body_ in
          let _startpos = _startpos__1_ in
          (
# 495 "lib/parser.mly"
      ( n _startpos _endpos (Ast.SWhile { cond; body }) )
# 5760 "lib/parser.ml"
           : (Ast.stmt Ast.node))
        in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
    |]
  
  and trace =
    None
  
end

module MenhirInterpreter = struct
  
  module ET = MenhirLib.TableInterpreter.MakeEngineTable (Tables)
  
  module TI = MenhirLib.Engine.Make (ET)
  
  include TI
  
  module Symbols = struct
    
    type _ terminal = 
      | T_error : unit terminal
      | T_XOR : unit terminal
      | T_WHILE : unit terminal
      | T_TRUE : unit terminal
      | T_TERM : unit terminal
      | T_TABLE : unit terminal
      | T_STRINGLIT : (
# 28 "lib/parser.mly"
       (string)
# 5797 "lib/parser.ml"
    ) terminal
      | T_STOP : unit terminal
      | T_START : unit terminal
      | T_STAR : unit terminal
      | T_SLASH : unit terminal
      | T_SEMI : unit terminal
      | T_RPAREN : unit terminal
      | T_RETURN : unit terminal
      | T_REF : unit terminal
      | T_PROC : unit terminal
      | T_POW : unit terminal
      | T_PLUS : unit terminal
      | T_OR : unit terminal
      | T_NOT : unit terminal
      | T_NE : unit terminal
      | T_MOD : unit terminal
      | T_MINUS : unit terminal
      | T_LT : unit terminal
      | T_LPAREN : unit terminal
      | T_LE : unit terminal
      | T_ITEM : unit terminal
      | T_INTLIT : (
# 26 "lib/parser.mly"
       (string)
# 5822 "lib/parser.ml"
    ) terminal
      | T_IF : unit terminal
      | T_ID : (
# 25 "lib/parser.mly"
       (string)
# 5828 "lib/parser.ml"
    ) terminal
      | T_GT : unit terminal
      | T_GOTO : unit terminal
      | T_GE : unit terminal
      | T_FOR : unit terminal
      | T_FLOATLIT : (
# 27 "lib/parser.mly"
       (string)
# 5837 "lib/parser.ml"
    ) terminal
      | T_FALSE : unit terminal
      | T_EXIT : unit terminal
      | T_EQV : unit terminal
      | T_EQ : unit terminal
      | T_EOF : unit terminal
      | T_END : unit terminal
      | T_ELSE : unit terminal
      | T_DOT : unit terminal
      | T_DEFAULT : unit terminal
      | T_DEF : unit terminal
      | T_COMMA : unit terminal
      | T_COLON : unit terminal
      | T_CHARLIT : (
# 29 "lib/parser.mly"
       (char)
# 5854 "lib/parser.ml"
    ) terminal
      | T_CASE : unit terminal
      | T_BY : unit terminal
      | T_BEGIN : unit terminal
      | T_BANG : unit terminal
      | T_AT : unit terminal
      | T_AND : unit terminal
      | T_ABORT : unit terminal
    
    type _ nonterminal = 
      | N_while_stmt : (Ast.stmt Ast.node) nonterminal
      | N_while_opt : (Ast.expr Ast.node option) nonterminal
      | N_type_spec : (Ast.type_expr Ast.node) nonterminal
      | N_type_sizes_opt : (Ast.expr Ast.node list) nonterminal
      | N_terminator : (unit) nonterminal
      | N_table_dims : (Ast.expr Ast.node list) nonterminal
      | N_stop_stmt : (Ast.stmt Ast.node) nonterminal
      | N_statement : (Ast.stmt Ast.node) nonterminal
      | N_simple_stmt : (Ast.stmt Ast.node) nonterminal
      | N_simple_or_control_stmt : (Ast.stmt Ast.node) nonterminal
      | N_rev_module_items : (Ast.toplevel list list) nonterminal
      | N_rev_field_decl_list : (Ast.field_decl Ast.node list) nonterminal
      | N_rev_decl_section : (Ast.decl Ast.node list list) nonterminal
      | N_return_stmt : (Ast.stmt Ast.node) nonterminal
      | N_record_opt : (Ast.field_decl Ast.node list option) nonterminal
      | N_program : (Ast.program) nonterminal
      | N_proc_decl : (Ast.decl Ast.node list) nonterminal
      | N_proc_body_opt : ((Ast.decl Ast.node list * Ast.stmt Ast.node) option) nonterminal
      | N_primary : (Ast.expr Ast.node) nonterminal
      | N_postfix_atom : (Ast.expr Ast.node) nonterminal
      | N_postfix : (Ast.expr Ast.node) nonterminal
      | N_outs_opt : (Ast.ident list) nonterminal
      | N_module_items : (Ast.program) nonterminal
      | N_module_item : (Ast.toplevel list) nonterminal
      | N_modifier_opt : (string option) nonterminal
      | N_lvalue_list : (Ast.expr Ast.node list) nonterminal
      | N_lvalue : (Ast.expr Ast.node) nonterminal
      | N_literal : (Ast.literal) nonterminal
      | N_labels_opt : (Ast.ident list) nonterminal
      | N_label : (Ast.ident) nonterminal
      | N_init_opt : (Ast.expr Ast.node option) nonterminal
      | N_if_stmt : (Ast.stmt Ast.node) nonterminal
      | N_ident : (Ast.ident) nonterminal
      | N_id_list : (Ast.ident list) nonterminal
      | N_goto_stmt : (Ast.stmt Ast.node) nonterminal
      | N_formals_opt : (Ast.param Ast.node list) nonterminal
      | N_formal_param_groups_opt : (Ast.param Ast.node list) nonterminal
      | N_formal_param_groups : (Ast.param Ast.node list) nonterminal
      | N_for_stmt : (Ast.stmt Ast.node) nonterminal
      | N_field_decl_list : (Ast.field_decl Ast.node list) nonterminal
      | N_field_decl : (Ast.field_decl Ast.node) nonterminal
      | N_expr_opt : (Ast.expr Ast.node option) nonterminal
      | N_expr_list_opt : (Ast.expr Ast.node list) nonterminal
      | N_expr_list : (Ast.expr Ast.node list) nonterminal
      | N_expr : (Ast.expr Ast.node) nonterminal
      | N_exit_stmt : (Ast.stmt Ast.node) nonterminal
      | N_else_opt : (Ast.stmt Ast.node option) nonterminal
      | N_directive_decl : (Ast.decl Ast.node) nonterminal
      | N_directive_args_opt : (string Ast.node list) nonterminal
      | N_directive_args : (string Ast.node list) nonterminal
      | N_directive_arg : (string Ast.node) nonterminal
      | N_dim_list_opt : (Ast.expr Ast.node list) nonterminal
      | N_dim_list : (Ast.expr Ast.node list) nonterminal
      | N_dim : (Ast.expr Ast.node) nonterminal
      | N_decl_section : (Ast.decl Ast.node list) nonterminal
      | N_decl_item : (Ast.decl Ast.node list) nonterminal
      | N_data_decl : (Ast.decl Ast.node list) nonterminal
      | N_compound_stmt : (Ast.stmt Ast.node) nonterminal
      | N_case_stmt : (Ast.stmt Ast.node) nonterminal
      | N_case_sep : (unit) nonterminal
      | N_case_options : ((Ast.expr Ast.node list * Ast.stmt Ast.node) list) nonterminal
      | N_case_option : (Ast.expr Ast.node list * Ast.stmt Ast.node) nonterminal
      | N_case_index_list : (Ast.expr Ast.node list) nonterminal
      | N_case_index : (Ast.expr Ast.node) nonterminal
      | N_call_stmt : (Ast.stmt Ast.node) nonterminal
      | N_by_opt : (Ast.expr Ast.node option) nonterminal
      | N_block_list_opt : (Ast.stmt Ast.node list) nonterminal
      | N_block_list : (Ast.stmt Ast.node list) nonterminal
      | N_assign_stmt : (Ast.stmt Ast.node) nonterminal
      | N_actuals_opt : (Ast.expr Ast.node list) nonterminal
      | N_abort_stmt : (Ast.stmt Ast.node) nonterminal
    
  end
  
  include Symbols
  
  include MenhirLib.InspectionTableInterpreter.Make (Tables) (struct
    
    include TI
    
    include Symbols
    
    include MenhirLib.InspectionTableInterpreter.Symbols (Symbols)
    
    let terminal =
      fun t ->
        match t with
        | 0 ->
            X (T T_error)
        | 1 ->
            X (T T_XOR)
        | 2 ->
            X (T T_WHILE)
        | 3 ->
            X (T T_TRUE)
        | 4 ->
            X (T T_TERM)
        | 5 ->
            X (T T_TABLE)
        | 6 ->
            X (T T_STRINGLIT)
        | 7 ->
            X (T T_STOP)
        | 8 ->
            X (T T_START)
        | 9 ->
            X (T T_STAR)
        | 10 ->
            X (T T_SLASH)
        | 11 ->
            X (T T_SEMI)
        | 12 ->
            X (T T_RPAREN)
        | 13 ->
            X (T T_RETURN)
        | 14 ->
            X (T T_REF)
        | 15 ->
            X (T T_PROC)
        | 16 ->
            X (T T_POW)
        | 17 ->
            X (T T_PLUS)
        | 18 ->
            X (T T_OR)
        | 19 ->
            X (T T_NOT)
        | 20 ->
            X (T T_NE)
        | 21 ->
            X (T T_MOD)
        | 22 ->
            X (T T_MINUS)
        | 23 ->
            X (T T_LT)
        | 24 ->
            X (T T_LPAREN)
        | 25 ->
            X (T T_LE)
        | 26 ->
            X (T T_ITEM)
        | 27 ->
            X (T T_INTLIT)
        | 28 ->
            X (T T_IF)
        | 29 ->
            X (T T_ID)
        | 30 ->
            X (T T_GT)
        | 31 ->
            X (T T_GOTO)
        | 32 ->
            X (T T_GE)
        | 33 ->
            X (T T_FOR)
        | 34 ->
            X (T T_FLOATLIT)
        | 35 ->
            X (T T_FALSE)
        | 36 ->
            X (T T_EXIT)
        | 37 ->
            X (T T_EQV)
        | 38 ->
            X (T T_EQ)
        | 39 ->
            X (T T_EOF)
        | 40 ->
            X (T T_END)
        | 41 ->
            X (T T_ELSE)
        | 42 ->
            X (T T_DOT)
        | 43 ->
            X (T T_DEFAULT)
        | 44 ->
            X (T T_DEF)
        | 45 ->
            X (T T_COMMA)
        | 46 ->
            X (T T_COLON)
        | 47 ->
            X (T T_CHARLIT)
        | 48 ->
            X (T T_CASE)
        | 49 ->
            X (T T_BY)
        | 50 ->
            X (T T_BEGIN)
        | 51 ->
            X (T T_BANG)
        | 52 ->
            X (T T_AT)
        | 53 ->
            X (T T_AND)
        | 54 ->
            X (T T_ABORT)
        | _ ->
            assert false
    
    and nonterminal =
      fun nt ->
        match nt with
        | 71 ->
            X (N N_abort_stmt)
        | 70 ->
            X (N N_actuals_opt)
        | 69 ->
            X (N N_assign_stmt)
        | 68 ->
            X (N N_block_list)
        | 67 ->
            X (N N_block_list_opt)
        | 66 ->
            X (N N_by_opt)
        | 65 ->
            X (N N_call_stmt)
        | 64 ->
            X (N N_case_index)
        | 63 ->
            X (N N_case_index_list)
        | 62 ->
            X (N N_case_option)
        | 61 ->
            X (N N_case_options)
        | 60 ->
            X (N N_case_sep)
        | 59 ->
            X (N N_case_stmt)
        | 58 ->
            X (N N_compound_stmt)
        | 57 ->
            X (N N_data_decl)
        | 56 ->
            X (N N_decl_item)
        | 55 ->
            X (N N_decl_section)
        | 54 ->
            X (N N_dim)
        | 53 ->
            X (N N_dim_list)
        | 52 ->
            X (N N_dim_list_opt)
        | 51 ->
            X (N N_directive_arg)
        | 50 ->
            X (N N_directive_args)
        | 49 ->
            X (N N_directive_args_opt)
        | 48 ->
            X (N N_directive_decl)
        | 47 ->
            X (N N_else_opt)
        | 46 ->
            X (N N_exit_stmt)
        | 45 ->
            X (N N_expr)
        | 44 ->
            X (N N_expr_list)
        | 43 ->
            X (N N_expr_list_opt)
        | 42 ->
            X (N N_expr_opt)
        | 41 ->
            X (N N_field_decl)
        | 40 ->
            X (N N_field_decl_list)
        | 39 ->
            X (N N_for_stmt)
        | 38 ->
            X (N N_formal_param_groups)
        | 37 ->
            X (N N_formal_param_groups_opt)
        | 36 ->
            X (N N_formals_opt)
        | 35 ->
            X (N N_goto_stmt)
        | 34 ->
            X (N N_id_list)
        | 33 ->
            X (N N_ident)
        | 32 ->
            X (N N_if_stmt)
        | 31 ->
            X (N N_init_opt)
        | 30 ->
            X (N N_label)
        | 29 ->
            X (N N_labels_opt)
        | 28 ->
            X (N N_literal)
        | 27 ->
            X (N N_lvalue)
        | 26 ->
            X (N N_lvalue_list)
        | 25 ->
            X (N N_modifier_opt)
        | 24 ->
            X (N N_module_item)
        | 23 ->
            X (N N_module_items)
        | 22 ->
            X (N N_outs_opt)
        | 21 ->
            X (N N_postfix)
        | 20 ->
            X (N N_postfix_atom)
        | 19 ->
            X (N N_primary)
        | 18 ->
            X (N N_proc_body_opt)
        | 17 ->
            X (N N_proc_decl)
        | 16 ->
            X (N N_program)
        | 15 ->
            X (N N_record_opt)
        | 14 ->
            X (N N_return_stmt)
        | 13 ->
            X (N N_rev_decl_section)
        | 12 ->
            X (N N_rev_field_decl_list)
        | 11 ->
            X (N N_rev_module_items)
        | 10 ->
            X (N N_simple_or_control_stmt)
        | 9 ->
            X (N N_simple_stmt)
        | 8 ->
            X (N N_statement)
        | 7 ->
            X (N N_stop_stmt)
        | 6 ->
            X (N N_table_dims)
        | 5 ->
            X (N N_terminator)
        | 4 ->
            X (N N_type_sizes_opt)
        | 3 ->
            X (N N_type_spec)
        | 2 ->
            X (N N_while_opt)
        | 1 ->
            X (N N_while_stmt)
        | _ ->
            assert false
    
    and lr0_incoming =
      (8, "\000\018\023\030<Zf\017;\006\b\014$(.28FH`')2+j)VC9CW\026Y[\004[\020[\022[\"[$[&[*[,[.[0[4[>[B[L[N[l[\\Y[\026[[[[\024\017u\016\028U[:[\024\017T\017_\017_@CDC^[d[\133\006[\005\024\017Jb[\024f2X[.[^[\127\026^hyn\003\015\019\024\\\011\021\029+5N[7\\5AC2W\026\141GO]w\131\139\143\129\\\127{R}{\021=C^\137\135R\137\017#13\012C2\020[.[^[i\026km\\k\r\\f6C\007?\011[C\t[$[.[\t\025SQRS\031\011 C2C\\EEE^E-K\026MI\011f\02736C\007?\011C\0148<Fc\011eg\\easo\135R%aqs/\nPP!/P")
    
    and rhs =
      ((8, "!n2W\0265N[\017\017\137\137d[C\141X[[^[[.[\129\129\\\1272\127\026y\021}{^hb[\024f{Rf\135R36C\007?\0113\012C\r\031\011as#\027\020[[^[[.[mm\\kk\0148F<gg\\eeCc\011T\017J+([$[.[[\"[[\020[[\022[[,[[$[[.[[0[[4[[>[[B[[N[[*[[l[[&[[\004[[L[[[\\YY[6C\007?\011\025DC^[\133\005\024\017E-M2K\026@CCC\\ECE<:[\024\017_:[\017_[C^;=8F\014`\bH+77\\5Z\030q\017\023^E)+j)')VC)2W\026C92[\026fo\135R3 CI\011%\018/\nP/P\018/P\\fQR\028U\027s\027aS\025S\0231A\003Ow\019\011\139G\029\131]\143\015u;\021\0162i\026\024\\[\tC\t\006[\006[\024\017"), (16, "\000\000\000\001\000\002\000\002\000\005\000\b\000\t\000\011\000\011\000\012\000\012\000\014\000\016\000\017\000\018\000\021\000\024\000\025\000\028\000!\000!\000#\000$\000%\000+\000.\0004\000:\000;\000<\000=\000>\000?\000@\000C\000F\000G\000J\000J\000K\000L\000M\000N\000O\000P\000S\000S\000T\000W\000W\000Y\000Z\000[\000]\000_\000a\000d\000g\000j\000m\000p\000s\000v\000y\000|\000\127\000\130\000\133\000\136\000\139\000\142\000\145\000\146\000\149\000\149\000\150\000\150\000\151\000\156\000\156\000\157\000\165\000\167\000\167\000\168\000\168\000\171\000\173\000\174\000\177\000\179\000\180\000\185\000\189\000\189\000\190\000\192\000\192\000\194\000\195\000\196\000\197\000\198\000\199\000\200\000\201\000\202\000\205\000\205\000\206\000\207\000\208\000\209\000\210\000\210\000\212\000\213\000\216\000\217\000\220\000\224\000\225\000\226\000\229\000\229\000\233\000\239\000\243\000\245\000\248\000\248\000\252\000\254\000\254\001\000\001\002\001\003\001\005\001\005\001\007\001\b\001\t\001\n\001\011\001\r\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\023\001\024\001\027\001\028\001\029\001\029\001\031\001!\001!\001#\001'"))
    
    and lr0_core =
      (16, "\000\000\000\001\000\002\000\003\000\004\000\005\000\006\000\007\000\b\000\t\000\n\000\011\000\012\000\r\000\014\000\015\000\016\000\017\000\018\000\019\000\020\000\021\000\022\000\023\000\024\000\025\000\026\000\027\000\028\000\029\000\030\000\031\000 \000!\000\"\000#\000$\000%\000(\000)\000&\000'\000*\000+\0000\0001\000.\000/\0002\0003\0004\0005\0006\0007\0008\0009\000:\000;\000>\000?\000@\000A\000,\000-\000<\000=\000B\000C\000D\000E\000F\000G\000H\000I\000J\000K\000L\000M\000N\000O\000P\000Q\000R\000S\000T\000U\000V\000W\000X\000Y\000Z\000[\000\\\000]\000^\000_\000`\000a\000b\000c\000d\000e\000f\000g\000h\000i\000j\000k\000l\000m\000n\000o\000p\000q\000r\000s\000t\000u\000v\000w\000x\000y\000z\000{\000|\000}\000~\000\127\000\128\000\129\000\130\000\131\000\132\000\133\000\134\000\135\000\136\000\137\000\138\000\139\000\140\000\141\000\142\000\143\000\144\000\145\000\146\000\147\000\148\000\149\000\150\000\151\000\152\000\153\000\154\000\155\000\156\000\157\000\158\000\159\000\160\000\161\000\162\000\163\000\164\000\165\000\166\000\167\000\168\000\169\000\170\000\171\000\172\000\173\000\174\000\175\000\176\000\177\000\178\000\179\000\180\000\181\000\182\000\183\000\184\000\185\000\186\000\187\000\188\000\189\000\190\000\191\000\192\000\193\000\194\000\195\000\196\000\197\000\198\000\199\000\200\000\201\000\202\000\203\000\204\000\205\000\206\000\207\000\208\000\209\000\210\000\211\000\212\000\213\000\214\000\215\000\216\000\217\000\218\000\219\000\220\000\221\000\222\000\223\000\224\000\225\000\226\000\227\000\228\000\229\000\230\000\231\000\232\000\233\000\234\000\235\000\236\000\237\000\238\000\239\000\240\000\241\000\242\000\243\000\244\000\245\000\246\000\247\000\248\000\249\000\250\000\251\000\252\000\253\000\254\000\255\001\000\001\001\001\002")
    
    and lr0_items =
      ((32, "\000\000\000\000\000\002\000\001\000\001\248\001\000\002(\001\000\001\192\001\000\001\180\001\000\001h\001\000\001\176\001\000\000`\001\000\000\024\001\000\000\020\001\000\002`\001\000\001\132\001\000\002\136\001\000\001\152\001\000\001\144\001\000\000\212\001\000\000\208\001\000\000\216\001\000\001\232\001\000\001\136\001\000\001\140\001\000\001\156\001\000\001\148\001\000\001\212\001\000\001\220\001\000\001\216\001\000\001\204\001\000\001\220\002\000\001\208\001\000\000\204\001\000\001\208\002\000\001\220\001\000\001\216\001\000\001\208\003\000\001\216\002\000\001\216\003\000\001\228\001\000\001\224\001\000\001\220\003\000\001\220\004\000\001(\001\000\001 \001\000\001\028\001\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001\020\002\000\001\024\001\000\001\020\003\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\224\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\003\000\000\224\001\000\000\220\001\000\000\228\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\003\000\000\228\001\000\000\224\001\000\000\220\001\000\000\220\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\003\000\000\220\001\000\000\236\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\003\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001\016\002\000\001\024\001\000\001\020\001\000\001\016\003\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001\b\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\003\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\232\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\003\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\240\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\003\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\244\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\003\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\248\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\003\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\252\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\003\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001\000\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\003\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001\024\002\000\001\024\003\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001\004\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\003\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001\012\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\003\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001 \002\000\001 \003\000\001\232\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001\232\003\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\216\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\208\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\212\002\000\002\136\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\002\136\003\000\002\136\004\000\002\\\001\000\002d\001\000\002\012\001\000\002\012\002\000\0010\001\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001p\001\000\001l\001\000\001p\002\000\001l\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001l\003\000\001l\004\000\000\196\001\000\000\196\002\000\001l\005\000\001p\003\000\001p\004\000\001X\001\000\001X\002\000\001@\001\000\001@\002\000\001@\003\000\001@\004\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000(\001\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000(\002\000\001@\005\000\002\132\001\000\002\132\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\001@\006\000\001@\007\000\001@\b\000\000\200\001\000\000\\\001\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\\\002\000\000\\\003\000\000\\\004\000\000H\001\000\0000\001\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000<\001\000\0008\001\000\0004\001\000\000\240\002\000\000<\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\003\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000<\003\000\0008\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\0008\003\000\000H\002\000\000H\003\000\000T\001\000\000X\001\000\000H\004\000\000\004\001\000\0020\001\000\002X\001\000\002<\001\000\002l\001\000\002p\001\000\002<\002\000\000H\005\000\002H\001\000\001\208\001\000\001\160\001\000\000\016\001\000\000\016\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\016\003\000\001\168\001\000\001\164\001\000\001\168\002\000\001\168\003\000\002,\001\000\001\224\001\000\000,\001\000\000\012\001\000\000\012\002\000\000\012\003\000\000,\002\000\002D\001\000\0024\001\000\002P\001\000\0028\001\000\002L\001\000\002@\001\000\002T\001\000\000D\001\000\000@\001\000\000D\002\000\000D\003\000\000\\\005\000\000\\\006\000\000P\001\000\000P\002\000\002`\002\000\001\132\002\000\001\224\001\000\001|\001\000\000,\001\000\001|\002\000\000\024\002\000\000`\002\000\000`\003\000\000 \001\000\001\188\001\000\000t\001\000\002(\002\000\001\244\001\000\000h\001\000\000d\001\000\000h\002\000\000h\003\000\002h\001\000\000|\001\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\136\001\000\000\132\001\000\000\128\001\000\000\240\002\000\000\136\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\003\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\136\003\000\000\132\002\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\132\003\000\002h\002\000\002h\003\000\000\152\001\000\000\144\001\000\000\140\001\000\000\144\002\000\000\144\003\000\000h\004\000\002\b\001\000\002\b\002\000\0014\001\000\0014\002\000\0014\003\000\0014\004\000\0014\005\000\001x\001\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\002|\001\000\002|\002\000\002x\001\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\236\002\000\000\212\001\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\001\000\000\236\003\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\212\002\000\000\240\002\000\000\216\001\000\001\024\001\000\001\020\001\000\001\016\001\000\001\012\001\000\001\b\001\000\001\004\001\000\001\000\001\000\000\252\001\000\000\248\001\000\000\244\001\000\000\240\003\000\000\240\001\000\000\236\001\000\000\232\001\000\000\228\001\000\000\224\001\000\000\220\001\000\000\216\002\000\002x\002\000\002 \001\000\001<\001\000\002 \002\000\002\b\003\000\002\b\004\000\002\028\001\000\000h\005\000\000h\006\000\001\244\002\000\001\244\003\000\001T\001\000\001d\001\000\001`\001\000\001\\\001\000\001`\002\000\001`\003\000\001d\002\000\001D\001\000\001\200\001\000\001\200\002\000\001D\002\000\001T\002\000\001T\003\000\001L\001\000\001\244\004\000\001\244\005\000\001\240\001\000\002\024\001\000\002\020\001\000\000x\001\000\000h\001\000\000d\001\000\000d\002\000\000d\003\000\000d\004\000\000d\005\000\000d\006\000\000\188\001\000\000\156\001\000\000\160\001\000\000\168\001\000\000\164\001\000\000\188\002\000\000\188\003\000\000\184\001\000\000\176\001\000\000\172\001\000\000\176\002\000\000\176\003\000\002\024\002\000\002\020\002\000\001\240\002\000\001\240\003\000\001\240\004\000\001\244\006\000\000l\001\000\001\184\001\000\000p\001\000\002\000\002\000\001\248\002\000\001\248\003\000\001\248\004\000\002\000\003\000\000\000\001\000\001\252\001\000\001\252\002"), (16, "\000\000\000\001\000\003\000\005\000\006\000\007\000\b\000\t\000\011\000\r\000\014\000\015\000\016\000\017\000\018\000\019\000\020\000\021\000\022\000\023\000\024\000\025\000\028\000\029\000\031\000 \000#\000$\000%\000&\000'\000(\000)\000*\000<\000=\000N\000O\000`\000a\000r\000s\000\132\000\133\000\150\000\151\000\168\000\169\000\186\000\187\000\204\000\205\000\222\000\223\000\240\000\241\001\002\001\003\001\020\001\021\001&\001'\0018\0019\001J\001K\001\\\001]\001^\001o\001p\001\129\001\146\001\163\001\180\001\181\001\182\001\183\001\184\001\185\001\186\001\203\001\205\001\223\001\224\001\225\001\226\001\227\001\228\001\229\001\230\001\231\001\232\001\233\001\234\001\235\001\252\001\253\002\014\002\015\002\016\002!\002\"\002#\002$\002%\002&\0027\0028\0029\002:\002;\002N\002P\002b\002c\002t\002u\002v\002w\002x\002y\002z\002{\002|\002}\002~\002\127\002\128\002\129\002\130\002\132\002\133\002\134\002\151\002\153\002\154\002\155\002\156\002\158\002\159\002\160\002\161\002\162\002\163\002\164\002\165\002\166\002\167\002\168\002\169\002\171\002\172\002\173\002\174\002\175\002\176\002\177\002\178\002\179\002\182\002\183\002\184\002\185\002\186\002\187\002\188\002\189\002\190\002\193\002\194\002\195\002\196\002\197\002\216\002\218\002\236\002\237\002\254\002\255\003\000\003\001\003\003\003\004\003\005\003\006\003\007\003\b\003\t\003\n\003\011\003\012\003\r\003\030\003\031\003 \0031\0033\003E\003G\003Y\003Z\003\\\003]\003^\003_\003`\003a\003b\003c\003d\003e\003h\003i\003j\003k\003l\003m\003n\003o\003p\003q\003r\003s\003t\003u\003x\003z\003{\003|\003}\003~\003\127\003\128\003\129\003\130\003\131\003\132\003\133\003\134\003\135\003\137\003\138\003\139\003\140\003\141\003\142\003\143\003\144\003\145\003\146\003\147\003\148\003\150\003\151\003\152\003\153\003\154\003\155\003\156"))
    
    and nullable =
      "(\021#E\012\177I\0042"
    
    and first =
      (55, "7\135\000\189y\t\162@\000\000\000\000\000\000\128\000\000\000\000\000\000\000\000\000 \000\000\001 \005)C\000\016\000\002\000\000\000\000\128\000\000\000 \000\000\000\000\128\000\000\000\000\0003\004\000\157x\001\162&\b\001*p\002\004\204\016\002u\224\006\t\1848\005\235\192M\016\000\000\002\000\000\000\000\128@\004\128\001\000\000\001\000\000\000\000\000\000\000\000\000\000\002\0007\135\000\189y\t\162\000\006\000\000\000\016\000\000\000\000\000\000\000\128\144\000\004\161\128\b\001 \000\tC\000\016\002@\000\018\134\000 \000\000\000\000\000\000\128\027\131\128^\188\004\2097\007\000\189x\t\162\000\004\000\000\000\016\000H\000\002P\192\004\000\144\000\004\161\128\b\001 \000\001\003\000\016\000\000\000\000\128\000\000\000\000\000\001\000\000\000\t\000)J\024\000\128\000\000\000\b\000\000\000\000\000\000\b\000\000\000\000\000\000\016\000\000\000\000\000\000\b\000\000\000\000\000\b\000\000\000\000\000\000\000\128\000\000\000\000\000\001\000\000\000\000\000\000\000 \000\000\000\000\000 \000\000\000\000\000\000@\000\000\000H\001JP\192\004\000\144\002\148\161\128\b\001 \005)C\000\016\002@\nR\134\000 \000\000\000\000\002\000\000\000\000\000\000\000 \000\000\000\000\004\000\000\000\004\000\000(@\000\000\b\000\000P\128\000\000\016\000\000\161\000\000\001$\005)C\000\016\002H\nR\134\000 \004\144\020\165\012\000@\002\001\000\018\000\004\000\004\003\000$\000\b\000\b\004\000@\000\016\000\000\000\000\000\000\000\128\000\000\000\000\000\004\000\000\000\000\000\000!\000\000\000\016\000\000\000\000\000\000 \000\000\000\t\000)J\024\b\128\018\000R\1480\017\000\000\000\000\b\000\000\000\000\000\000\000\000\001\001\152 \004\235\192\r\0190@\t\215\128\026\"@\000\018\134\000 \000\000\000 \000\000\000\000\000\000\000\000\000\001")
    
  end) (ET) (TI)
  
end

let program =
  fun lexer lexbuf : (Ast.program) ->
    Obj.magic (MenhirInterpreter.entry `Legacy 0 lexer lexbuf)

module Incremental = struct
  
  let program =
    fun initial_position : (Ast.program) MenhirInterpreter.checkpoint ->
      Obj.magic (MenhirInterpreter.start 0 initial_position)
  
end
